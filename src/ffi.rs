/* automatically generated by rust-bindgen 0.59.1 */

pub const AOM_IMAGE_ABI_VERSION: u32 = 5;
pub const AOM_IMG_FMT_PLANAR: u32 = 256;
pub const AOM_IMG_FMT_UV_FLIP: u32 = 512;
pub const AOM_IMG_FMT_HIGHBITDEPTH: u32 = 2048;
pub const AOM_PLANE_PACKED: u32 = 0;
pub const AOM_PLANE_Y: u32 = 0;
pub const AOM_PLANE_U: u32 = 1;
pub const AOM_PLANE_V: u32 = 2;
pub const AOM_CODEC_ABI_VERSION: u32 = 8;
pub const AOM_CODEC_CAP_DECODER: u32 = 1;
pub const AOM_CODEC_CAP_ENCODER: u32 = 2;
pub const AOM_ENCODER_ABI_VERSION: u32 = 13;
pub const AOM_CODEC_CAP_PSNR: u32 = 65536;
pub const AOM_CODEC_CAP_HIGHBITDEPTH: u32 = 262144;
pub const AOM_CODEC_USE_PSNR: u32 = 65536;
pub const AOM_CODEC_USE_HIGHBITDEPTH: u32 = 262144;
pub const AOM_FRAME_IS_KEY: u32 = 1;
pub const AOM_FRAME_IS_DROPPABLE: u32 = 2;
pub const AOM_FRAME_IS_INTRAONLY: u32 = 16;
pub const AOM_FRAME_IS_SWITCH: u32 = 32;
pub const AOM_FRAME_IS_ERROR_RESILIENT: u32 = 64;
pub const AOM_FRAME_IS_DELAYED_RANDOM_ACCESS_POINT: u32 = 128;
pub const AOM_ERROR_RESILIENT_DEFAULT: u32 = 1;
pub const AOM_EFLAG_FORCE_KF: u32 = 1;
pub const AOM_USAGE_GOOD_QUALITY: u32 = 0;
pub const AOM_USAGE_REALTIME: u32 = 1;
pub const AOM_MAXIMUM_WORK_BUFFERS: u32 = 8;
pub const AOM_MAXIMUM_REF_BUFFERS: u32 = 8;
pub const AOM_DECODER_ABI_VERSION: u32 = 11;
pub const AOM_CODEC_CAP_PUT_SLICE: u32 = 65536;
pub const AOM_CODEC_CAP_PUT_FRAME: u32 = 131072;
pub const AOM_CODEC_CAP_POSTPROC: u32 = 262144;
pub const AOM_CODEC_CAP_EXTERNAL_FRAME_BUFFER: u32 = 2097152;
pub const AOM_CODEC_USE_POSTPROC: u32 = 65536;
pub const AOM_EFLAG_NO_REF_LAST: u32 = 65536;
pub const AOM_EFLAG_NO_REF_LAST2: u32 = 131072;
pub const AOM_EFLAG_NO_REF_LAST3: u32 = 262144;
pub const AOM_EFLAG_NO_REF_GF: u32 = 524288;
pub const AOM_EFLAG_NO_REF_ARF: u32 = 1048576;
pub const AOM_EFLAG_NO_REF_BWD: u32 = 2097152;
pub const AOM_EFLAG_NO_REF_ARF2: u32 = 4194304;
pub const AOM_EFLAG_NO_UPD_LAST: u32 = 8388608;
pub const AOM_EFLAG_NO_UPD_GF: u32 = 16777216;
pub const AOM_EFLAG_NO_UPD_ARF: u32 = 33554432;
pub const AOM_EFLAG_NO_UPD_ENTROPY: u32 = 67108864;
pub const AOM_EFLAG_NO_REF_FRAME_MVS: u32 = 134217728;
pub const AOM_EFLAG_ERROR_RESILIENT: u32 = 268435456;
pub const AOM_EFLAG_SET_S_FRAME: u32 = 536870912;
pub const AOM_EFLAG_SET_PRIMARY_REF_NONE: u32 = 1073741824;
pub const AOM_MAX_SEGMENTS: u32 = 8;
pub const AOM_MAX_LAYERS: u32 = 32;
pub const AOM_MAX_SS_LAYERS: u32 = 4;
pub const AOM_MAX_TS_LAYERS: u32 = 8;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn aom_uleb_size_in_bytes(value: u64) -> usize;
}
extern "C" {
    pub fn aom_uleb_decode(
        buffer: *const u8,
        available: usize,
        value: *mut u64,
        length: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aom_uleb_encode(
        value: u64,
        available: usize,
        coded_value: *mut u8,
        coded_size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aom_uleb_encode_fixed_size(
        value: u64,
        available: usize,
        pad_to_size: usize,
        coded_value: *mut u8,
        coded_size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
pub const AOM_IMG_FMT_NONE: aom_img_fmt = 0;
pub const AOM_IMG_FMT_YV12: aom_img_fmt = 769;
pub const AOM_IMG_FMT_I420: aom_img_fmt = 258;
pub const AOM_IMG_FMT_AOMYV12: aom_img_fmt = 771;
#[doc = "planar 4:2:0 format with aom color space"]
pub const AOM_IMG_FMT_AOMI420: aom_img_fmt = 260;
#[doc = " < planar 4:2:0 format with aom color space"]
pub const AOM_IMG_FMT_I422: aom_img_fmt = 261;
#[doc = " < planar 4:2:0 format with aom color space"]
pub const AOM_IMG_FMT_I444: aom_img_fmt = 262;
#[doc = " < planar 4:2:0 format with aom color space"]
pub const AOM_IMG_FMT_I42016: aom_img_fmt = 2306;
#[doc = " < planar 4:2:0 format with aom color space"]
pub const AOM_IMG_FMT_YV1216: aom_img_fmt = 2817;
#[doc = " < planar 4:2:0 format with aom color space"]
pub const AOM_IMG_FMT_I42216: aom_img_fmt = 2309;
#[doc = " < planar 4:2:0 format with aom color space"]
pub const AOM_IMG_FMT_I44416: aom_img_fmt = 2310;
#[doc = "List of supported image formats"]
pub type aom_img_fmt = ::std::os::raw::c_uint;
#[doc = "\\brief List of supported image formats"]
pub use self::aom_img_fmt as aom_img_fmt_t;
#[doc = "< For future use"]
pub const AOM_CICP_CP_RESERVED_0: aom_color_primaries = 0;
#[doc = "< BT.709"]
pub const AOM_CICP_CP_BT_709: aom_color_primaries = 1;
#[doc = "< Unspecified"]
pub const AOM_CICP_CP_UNSPECIFIED: aom_color_primaries = 2;
#[doc = "< For future use"]
pub const AOM_CICP_CP_RESERVED_3: aom_color_primaries = 3;
#[doc = "< BT.470 System M (historical)"]
pub const AOM_CICP_CP_BT_470_M: aom_color_primaries = 4;
#[doc = "< BT.470 System B, G (historical)"]
pub const AOM_CICP_CP_BT_470_B_G: aom_color_primaries = 5;
#[doc = "< BT.601"]
pub const AOM_CICP_CP_BT_601: aom_color_primaries = 6;
#[doc = "< SMPTE 240"]
pub const AOM_CICP_CP_SMPTE_240: aom_color_primaries = 7;
pub const AOM_CICP_CP_GENERIC_FILM: aom_color_primaries = 8;
#[doc = "< BT.2020, BT.2100"]
pub const AOM_CICP_CP_BT_2020: aom_color_primaries = 9;
#[doc = "< SMPTE 428 (CIE 1921 XYZ)"]
pub const AOM_CICP_CP_XYZ: aom_color_primaries = 10;
#[doc = "< SMPTE RP 431-2"]
pub const AOM_CICP_CP_SMPTE_431: aom_color_primaries = 11;
#[doc = "< SMPTE EG 432-1"]
pub const AOM_CICP_CP_SMPTE_432: aom_color_primaries = 12;
#[doc = "< For future use (values 13 - 21)"]
pub const AOM_CICP_CP_RESERVED_13: aom_color_primaries = 13;
#[doc = "< EBU Tech. 3213-E"]
pub const AOM_CICP_CP_EBU_3213: aom_color_primaries = 22;
#[doc = "< For future use (values 23 - 255)"]
pub const AOM_CICP_CP_RESERVED_23: aom_color_primaries = 23;
#[doc = "\\brief List of supported color primaries"]
pub type aom_color_primaries = ::std::os::raw::c_uint;
#[doc = "\\brief List of supported color primaries"]
pub use self::aom_color_primaries as aom_color_primaries_t;
#[doc = "< For future use"]
pub const AOM_CICP_TC_RESERVED_0: aom_transfer_characteristics = 0;
#[doc = "< BT.709"]
pub const AOM_CICP_TC_BT_709: aom_transfer_characteristics = 1;
#[doc = "< Unspecified"]
pub const AOM_CICP_TC_UNSPECIFIED: aom_transfer_characteristics = 2;
#[doc = "< For future use"]
pub const AOM_CICP_TC_RESERVED_3: aom_transfer_characteristics = 3;
#[doc = "< BT.470 System M (historical)"]
pub const AOM_CICP_TC_BT_470_M: aom_transfer_characteristics = 4;
#[doc = "< BT.470 System B, G (historical)"]
pub const AOM_CICP_TC_BT_470_B_G: aom_transfer_characteristics = 5;
#[doc = "< BT.601"]
pub const AOM_CICP_TC_BT_601: aom_transfer_characteristics = 6;
#[doc = "< SMPTE 240 M"]
pub const AOM_CICP_TC_SMPTE_240: aom_transfer_characteristics = 7;
#[doc = "< Linear"]
pub const AOM_CICP_TC_LINEAR: aom_transfer_characteristics = 8;
#[doc = "< Logarithmic (100 : 1 range)"]
pub const AOM_CICP_TC_LOG_100: aom_transfer_characteristics = 9;
pub const AOM_CICP_TC_LOG_100_SQRT10: aom_transfer_characteristics = 10;
#[doc = "< IEC 61966-2-4"]
pub const AOM_CICP_TC_IEC_61966: aom_transfer_characteristics = 11;
#[doc = "< BT.1361"]
pub const AOM_CICP_TC_BT_1361: aom_transfer_characteristics = 12;
#[doc = "< sRGB or sYCC"]
pub const AOM_CICP_TC_SRGB: aom_transfer_characteristics = 13;
#[doc = "< BT.2020 10-bit systems"]
pub const AOM_CICP_TC_BT_2020_10_BIT: aom_transfer_characteristics = 14;
#[doc = "< BT.2020 12-bit systems"]
pub const AOM_CICP_TC_BT_2020_12_BIT: aom_transfer_characteristics = 15;
#[doc = "< SMPTE ST 2084, ITU BT.2100 PQ"]
pub const AOM_CICP_TC_SMPTE_2084: aom_transfer_characteristics = 16;
#[doc = "< SMPTE ST 428"]
pub const AOM_CICP_TC_SMPTE_428: aom_transfer_characteristics = 17;
#[doc = "< BT.2100 HLG, ARIB STD-B67"]
pub const AOM_CICP_TC_HLG: aom_transfer_characteristics = 18;
#[doc = "< For future use (values 19-255)"]
pub const AOM_CICP_TC_RESERVED_19: aom_transfer_characteristics = 19;
#[doc = "\\brief List of supported transfer functions"]
pub type aom_transfer_characteristics = ::std::os::raw::c_uint;
#[doc = "\\brief List of supported transfer functions"]
pub use self::aom_transfer_characteristics as aom_transfer_characteristics_t;
#[doc = "< Identity matrix"]
pub const AOM_CICP_MC_IDENTITY: aom_matrix_coefficients = 0;
#[doc = "< BT.709"]
pub const AOM_CICP_MC_BT_709: aom_matrix_coefficients = 1;
#[doc = "< Unspecified"]
pub const AOM_CICP_MC_UNSPECIFIED: aom_matrix_coefficients = 2;
#[doc = "< For future use"]
pub const AOM_CICP_MC_RESERVED_3: aom_matrix_coefficients = 3;
#[doc = "< US FCC 73.628"]
pub const AOM_CICP_MC_FCC: aom_matrix_coefficients = 4;
#[doc = "< BT.470 System B, G (historical)"]
pub const AOM_CICP_MC_BT_470_B_G: aom_matrix_coefficients = 5;
#[doc = "< BT.601"]
pub const AOM_CICP_MC_BT_601: aom_matrix_coefficients = 6;
#[doc = "< SMPTE 240 M"]
pub const AOM_CICP_MC_SMPTE_240: aom_matrix_coefficients = 7;
#[doc = "< YCgCo"]
pub const AOM_CICP_MC_SMPTE_YCGCO: aom_matrix_coefficients = 8;
pub const AOM_CICP_MC_BT_2020_NCL: aom_matrix_coefficients = 9;
#[doc = "< BT.2020 constant luminance"]
pub const AOM_CICP_MC_BT_2020_CL: aom_matrix_coefficients = 10;
#[doc = "< SMPTE ST 2085 YDzDx"]
pub const AOM_CICP_MC_SMPTE_2085: aom_matrix_coefficients = 11;
pub const AOM_CICP_MC_CHROMAT_NCL: aom_matrix_coefficients = 12;
#[doc = "< Chromaticity-derived constant luminance"]
pub const AOM_CICP_MC_CHROMAT_CL: aom_matrix_coefficients = 13;
#[doc = "< BT.2100 ICtCp"]
pub const AOM_CICP_MC_ICTCP: aom_matrix_coefficients = 14;
#[doc = "< For future use (values 15-255)"]
pub const AOM_CICP_MC_RESERVED_15: aom_matrix_coefficients = 15;
#[doc = "\\brief List of supported matrix coefficients"]
pub type aom_matrix_coefficients = ::std::os::raw::c_uint;
#[doc = "\\brief List of supported matrix coefficients"]
pub use self::aom_matrix_coefficients as aom_matrix_coefficients_t;
#[doc = "< Y [16..235], UV [16..240]"]
pub const AOM_CR_STUDIO_RANGE: aom_color_range = 0;
#[doc = "< YUV/RGB [0..255]"]
pub const AOM_CR_FULL_RANGE: aom_color_range = 1;
#[doc = "\\brief List of supported color range"]
pub type aom_color_range = ::std::os::raw::c_uint;
#[doc = "\\brief List of supported color range"]
pub use self::aom_color_range as aom_color_range_t;
#[doc = "< Unknown"]
pub const AOM_CSP_UNKNOWN: aom_chroma_sample_position = 0;
#[doc = "< Horizontally co-located with luma(0, 0)*/"]
pub const AOM_CSP_VERTICAL: aom_chroma_sample_position = 1;
#[doc = "< Co-located with luma(0, 0) sample"]
pub const AOM_CSP_COLOCATED: aom_chroma_sample_position = 2;
#[doc = "< Reserved value"]
pub const AOM_CSP_RESERVED: aom_chroma_sample_position = 3;
#[doc = "\\brief List of chroma sample positions"]
pub type aom_chroma_sample_position = ::std::os::raw::c_uint;
#[doc = "\\brief List of chroma sample positions"]
pub use self::aom_chroma_sample_position as aom_chroma_sample_position_t;
#[doc = "\\brief Image Descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_image {
    #[doc = "< Image Format"]
    pub fmt: aom_img_fmt_t,
    #[doc = "< CICP Color Primaries"]
    pub cp: aom_color_primaries_t,
    #[doc = "< CICP Transfer Characteristics"]
    pub tc: aom_transfer_characteristics_t,
    #[doc = "< CICP Matrix Coefficients"]
    pub mc: aom_matrix_coefficients_t,
    #[doc = "< Whether image is monochrome"]
    pub monochrome: ::std::os::raw::c_int,
    #[doc = "< chroma sample position"]
    pub csp: aom_chroma_sample_position_t,
    #[doc = "< Color Range"]
    pub range: aom_color_range_t,
    #[doc = "< Stored image width"]
    pub w: ::std::os::raw::c_uint,
    #[doc = "< Stored image height"]
    pub h: ::std::os::raw::c_uint,
    #[doc = "< Stored image bit-depth"]
    pub bit_depth: ::std::os::raw::c_uint,
    #[doc = "< Displayed image width"]
    pub d_w: ::std::os::raw::c_uint,
    #[doc = "< Displayed image height"]
    pub d_h: ::std::os::raw::c_uint,
    #[doc = "< Intended rendering image width"]
    pub r_w: ::std::os::raw::c_uint,
    #[doc = "< Intended rendering image height"]
    pub r_h: ::std::os::raw::c_uint,
    #[doc = "< subsampling order, X"]
    pub x_chroma_shift: ::std::os::raw::c_uint,
    #[doc = "< subsampling order, Y"]
    pub y_chroma_shift: ::std::os::raw::c_uint,
    #[doc = "< pointer to the top left pixel for each plane"]
    pub planes: [*mut ::std::os::raw::c_uchar; 3usize],
    #[doc = "< stride between rows for each plane"]
    pub stride: [::std::os::raw::c_int; 3usize],
    #[doc = "< data size"]
    pub sz: usize,
    #[doc = "< bits per sample (for packed formats)"]
    pub bps: ::std::os::raw::c_int,
    #[doc = "< Temporal layer Id of image"]
    pub temporal_id: ::std::os::raw::c_int,
    #[doc = "< Spatial layer Id of image"]
    pub spatial_id: ::std::os::raw::c_int,
    #[doc = "\\brief The following member may be set by the application to associate"]
    #[doc = " data with this image."]
    pub user_priv: *mut ::std::os::raw::c_void,
    #[doc = "< private"]
    pub img_data: *mut ::std::os::raw::c_uchar,
    #[doc = "< private"]
    pub img_data_owner: ::std::os::raw::c_int,
    #[doc = "< private"]
    pub self_allocd: ::std::os::raw::c_int,
    #[doc = "< Frame buffer data associated with the image."]
    pub fb_priv: *mut ::std::os::raw::c_void,
}
#[doc = "\\brief Image Descriptor"]
pub type aom_image_t = aom_image;
#[doc = "\\brief Representation of a rectangle on a surface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_image_rect {
    #[doc = "< leftmost column"]
    pub x: ::std::os::raw::c_uint,
    #[doc = "< topmost row"]
    pub y: ::std::os::raw::c_uint,
    #[doc = "< width"]
    pub w: ::std::os::raw::c_uint,
    #[doc = "< height"]
    pub h: ::std::os::raw::c_uint,
}
#[doc = "\\brief Representation of a rectangle on a surface"]
pub type aom_image_rect_t = aom_image_rect;
extern "C" {
    #[doc = "\\brief Open a descriptor, allocating storage for the underlying image"]
    #[doc = ""]
    #[doc = " Returns a descriptor for storing an image of the given format. The"]
    #[doc = " storage for the image is allocated on the heap."]
    #[doc = ""]
    #[doc = " \\param[in]    img       Pointer to storage for descriptor. If this parameter"]
    #[doc = "                         is NULL, the storage for the descriptor will be"]
    #[doc = "                         allocated on the heap."]
    #[doc = " \\param[in]    fmt       Format for the image"]
    #[doc = " \\param[in]    d_w       Width of the image"]
    #[doc = " \\param[in]    d_h       Height of the image"]
    #[doc = " \\param[in]    align     Alignment, in bytes, of the image buffer and"]
    #[doc = "                         each row in the image (stride)."]
    #[doc = ""]
    #[doc = " \\return Returns a pointer to the initialized image descriptor. If the img"]
    #[doc = "         parameter is non-null, the value of the img parameter will be"]
    #[doc = "         returned."]
    pub fn aom_img_alloc(
        img: *mut aom_image_t,
        fmt: aom_img_fmt_t,
        d_w: ::std::os::raw::c_uint,
        d_h: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
    ) -> *mut aom_image_t;
}
extern "C" {
    #[doc = "\\brief Open a descriptor, using existing storage for the underlying image"]
    #[doc = ""]
    #[doc = " Returns a descriptor for storing an image of the given format. The"]
    #[doc = " storage for the image has been allocated elsewhere, and a descriptor is"]
    #[doc = " desired to \"wrap\" that storage."]
    #[doc = ""]
    #[doc = " \\param[in]    img       Pointer to storage for descriptor. If this parameter"]
    #[doc = "                         is NULL, the storage for the descriptor will be"]
    #[doc = "                         allocated on the heap."]
    #[doc = " \\param[in]    fmt       Format for the image"]
    #[doc = " \\param[in]    d_w       Width of the image"]
    #[doc = " \\param[in]    d_h       Height of the image"]
    #[doc = " \\param[in]    align     Alignment, in bytes, of each row in the image"]
    #[doc = "                         (stride)."]
    #[doc = " \\param[in]    img_data  Storage to use for the image"]
    #[doc = ""]
    #[doc = " \\return Returns a pointer to the initialized image descriptor. If the img"]
    #[doc = "         parameter is non-null, the value of the img parameter will be"]
    #[doc = "         returned."]
    pub fn aom_img_wrap(
        img: *mut aom_image_t,
        fmt: aom_img_fmt_t,
        d_w: ::std::os::raw::c_uint,
        d_h: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
        img_data: *mut ::std::os::raw::c_uchar,
    ) -> *mut aom_image_t;
}
extern "C" {
    #[doc = "\\brief Open a descriptor, allocating storage for the underlying image with a"]
    #[doc = " border"]
    #[doc = ""]
    #[doc = " Returns a descriptor for storing an image of the given format and its"]
    #[doc = " borders. The storage for the image is allocated on the heap."]
    #[doc = ""]
    #[doc = " \\param[in]    img        Pointer to storage for descriptor. If this parameter"]
    #[doc = "                          is NULL, the storage for the descriptor will be"]
    #[doc = "                          allocated on the heap."]
    #[doc = " \\param[in]    fmt        Format for the image"]
    #[doc = " \\param[in]    d_w        Width of the image"]
    #[doc = " \\param[in]    d_h        Height of the image"]
    #[doc = " \\param[in]    align      Alignment, in bytes, of the image buffer and"]
    #[doc = "                          each row in the image (stride)."]
    #[doc = " \\param[in]    size_align Alignment, in pixels, of the image width and height."]
    #[doc = " \\param[in]    border     A border that is padded on four sides of the image."]
    #[doc = ""]
    #[doc = " \\return Returns a pointer to the initialized image descriptor. If the img"]
    #[doc = "         parameter is non-null, the value of the img parameter will be"]
    #[doc = "         returned."]
    pub fn aom_img_alloc_with_border(
        img: *mut aom_image_t,
        fmt: aom_img_fmt_t,
        d_w: ::std::os::raw::c_uint,
        d_h: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
        size_align: ::std::os::raw::c_uint,
        border: ::std::os::raw::c_uint,
    ) -> *mut aom_image_t;
}
extern "C" {
    #[doc = "\\brief Set the rectangle identifying the displayed portion of the image"]
    #[doc = ""]
    #[doc = " Updates the displayed rectangle (aka viewport) on the image surface to"]
    #[doc = " match the specified coordinates and size."]
    #[doc = ""]
    #[doc = " \\param[in]    img       Image descriptor"]
    #[doc = " \\param[in]    x         leftmost column"]
    #[doc = " \\param[in]    y         topmost row"]
    #[doc = " \\param[in]    w         width"]
    #[doc = " \\param[in]    h         height"]
    #[doc = " \\param[in]    border    A border that is padded on four sides of the image."]
    #[doc = ""]
    #[doc = " \\return 0 if the requested rectangle is valid, nonzero otherwise."]
    pub fn aom_img_set_rect(
        img: *mut aom_image_t,
        x: ::std::os::raw::c_uint,
        y: ::std::os::raw::c_uint,
        w: ::std::os::raw::c_uint,
        h: ::std::os::raw::c_uint,
        border: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Flip the image vertically (top for bottom)"]
    #[doc = ""]
    #[doc = " Adjusts the image descriptor's pointers and strides to make the image"]
    #[doc = " be referenced upside-down."]
    #[doc = ""]
    #[doc = " \\param[in]    img       Image descriptor"]
    pub fn aom_img_flip(img: *mut aom_image_t);
}
extern "C" {
    #[doc = "\\brief Close an image descriptor"]
    #[doc = ""]
    #[doc = " Frees all allocated storage associated with an image descriptor."]
    #[doc = ""]
    #[doc = " \\param[in]    img       Image descriptor"]
    pub fn aom_img_free(img: *mut aom_image_t);
}
extern "C" {
    #[doc = "\\brief Get the width of a plane"]
    #[doc = ""]
    #[doc = " Get the width of a plane of an image"]
    #[doc = ""]
    #[doc = " \\param[in]    img       Image descriptor"]
    #[doc = " \\param[in]    plane     Plane index"]
    pub fn aom_img_plane_width(
        img: *const aom_image_t,
        plane: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Get the height of a plane"]
    #[doc = ""]
    #[doc = " Get the height of a plane of an image"]
    #[doc = ""]
    #[doc = " \\param[in]    img       Image descriptor"]
    #[doc = " \\param[in]    plane     Plane index"]
    pub fn aom_img_plane_height(
        img: *const aom_image_t,
        plane: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = "\\brief Operation completed without error"]
pub const AOM_CODEC_OK: aom_codec_err_t = 0;
#[doc = "\\brief Unspecified error"]
pub const AOM_CODEC_ERROR: aom_codec_err_t = 1;
#[doc = "\\brief Memory operation failed"]
pub const AOM_CODEC_MEM_ERROR: aom_codec_err_t = 2;
#[doc = "\\brief ABI version mismatch"]
pub const AOM_CODEC_ABI_MISMATCH: aom_codec_err_t = 3;
#[doc = "\\brief Algorithm does not have required capability"]
pub const AOM_CODEC_INCAPABLE: aom_codec_err_t = 4;
#[doc = "\\brief The given bitstream is not supported."]
#[doc = ""]
#[doc = " The bitstream was unable to be parsed at the highest level. The decoder"]
#[doc = " is unable to proceed. This error \\ref SHOULD be treated as fatal to the"]
#[doc = " stream."]
pub const AOM_CODEC_UNSUP_BITSTREAM: aom_codec_err_t = 5;
#[doc = "\\brief Encoded bitstream uses an unsupported feature"]
#[doc = ""]
#[doc = " The decoder does not implement a feature required by the encoder. This"]
#[doc = " return code should only be used for features that prevent future"]
#[doc = " pictures from being properly decoded. This error \\ref MAY be treated as"]
#[doc = " fatal to the stream or \\ref MAY be treated as fatal to the current GOP."]
pub const AOM_CODEC_UNSUP_FEATURE: aom_codec_err_t = 6;
#[doc = "\\brief The coded data for this stream is corrupt or incomplete"]
#[doc = ""]
#[doc = " There was a problem decoding the current frame.  This return code"]
#[doc = " should only be used for failures that prevent future pictures from"]
#[doc = " being properly decoded. This error \\ref MAY be treated as fatal to the"]
#[doc = " stream or \\ref MAY be treated as fatal to the current GOP. If decoding"]
#[doc = " is continued for the current GOP, artifacts may be present."]
pub const AOM_CODEC_CORRUPT_FRAME: aom_codec_err_t = 7;
#[doc = "\\brief An application-supplied parameter is not valid."]
#[doc = ""]
pub const AOM_CODEC_INVALID_PARAM: aom_codec_err_t = 8;
#[doc = "\\brief An iterator reached the end of list."]
#[doc = ""]
pub const AOM_CODEC_LIST_END: aom_codec_err_t = 9;
#[doc = "\\brief Algorithm return codes"]
pub type aom_codec_err_t = ::std::os::raw::c_uint;
#[doc = " \\brief Codec capabilities bitfield"]
#[doc = ""]
#[doc = "  Each codec advertises the capabilities it supports as part of its"]
#[doc = "  ::aom_codec_iface_t interface structure. Capabilities are extra interfaces"]
#[doc = "  or functionality, and are not required to be supported."]
#[doc = ""]
#[doc = "  The available flags are specified by AOM_CODEC_CAP_* defines."]
pub type aom_codec_caps_t = ::std::os::raw::c_long;
#[doc = " \\brief Initialization-time Feature Enabling"]
#[doc = ""]
#[doc = "  Certain codec features must be known at initialization time, to allow for"]
#[doc = "  proper memory allocation."]
#[doc = ""]
#[doc = "  The available flags are specified by AOM_CODEC_USE_* defines."]
pub type aom_codec_flags_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_codec_iface {
    _unused: [u8; 0],
}
#[doc = "\\brief Codec interface structure."]
#[doc = ""]
#[doc = " Contains function pointers and other data private to the codec"]
#[doc = " implementation. This structure is opaque to the application."]
pub type aom_codec_iface_t = aom_codec_iface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_codec_priv {
    _unused: [u8; 0],
}
#[doc = "\\brief Codec private data structure."]
#[doc = ""]
#[doc = " Contains data private to the codec implementation. This structure is opaque"]
#[doc = " to the application."]
pub type aom_codec_priv_t = aom_codec_priv;
#[doc = "\\brief Iterator"]
#[doc = ""]
#[doc = " Opaque storage used for iterating over lists."]
pub type aom_codec_iter_t = *const ::std::os::raw::c_void;
#[doc = "\\brief Codec context structure"]
#[doc = ""]
#[doc = " All codecs \\ref MUST support this context structure fully. In general,"]
#[doc = " this data should be considered private to the codec algorithm, and"]
#[doc = " not be manipulated or examined by the calling application. Applications"]
#[doc = " may reference the 'name' member to get a printable description of the"]
#[doc = " algorithm."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aom_codec_ctx {
    #[doc = "< Printable interface name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Interface pointers"]
    pub iface: *mut aom_codec_iface_t,
    #[doc = "< Last returned error"]
    pub err: aom_codec_err_t,
    #[doc = "< Detailed info, if available"]
    pub err_detail: *const ::std::os::raw::c_char,
    #[doc = "< Flags passed at init time"]
    pub init_flags: aom_codec_flags_t,
    #[doc = "< Configuration pointer aliasing union"]
    pub config: aom_codec_ctx__bindgen_ty_1,
    #[doc = "< Algorithm private storage"]
    pub priv_: *mut aom_codec_priv_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union aom_codec_ctx__bindgen_ty_1 {
    pub dec: *const aom_codec_dec_cfg,
    pub enc: *const aom_codec_enc_cfg,
    pub raw: *const ::std::os::raw::c_void,
}
#[doc = "\\brief Codec context structure"]
#[doc = ""]
#[doc = " All codecs \\ref MUST support this context structure fully. In general,"]
#[doc = " this data should be considered private to the codec algorithm, and"]
#[doc = " not be manipulated or examined by the calling application. Applications"]
#[doc = " may reference the 'name' member to get a printable description of the"]
#[doc = " algorithm."]
pub type aom_codec_ctx_t = aom_codec_ctx;
#[doc = "<  8 bits"]
pub const AOM_BITS_8: aom_bit_depth = 8;
#[doc = "< 10 bits"]
pub const AOM_BITS_10: aom_bit_depth = 10;
#[doc = "< 12 bits"]
pub const AOM_BITS_12: aom_bit_depth = 12;
#[doc = "\\brief Bit depth for codec"]
#[doc = " *"]
#[doc = " This enumeration determines the bit depth of the codec."]
pub type aom_bit_depth = ::std::os::raw::c_uint;
#[doc = "\\brief Bit depth for codec"]
#[doc = " *"]
#[doc = " This enumeration determines the bit depth of the codec."]
pub use self::aom_bit_depth as aom_bit_depth_t;
#[doc = "< Always use 64x64 superblocks."]
pub const AOM_SUPERBLOCK_SIZE_64X64: aom_superblock_size = 0;
#[doc = "< Always use 128x128 superblocks."]
pub const AOM_SUPERBLOCK_SIZE_128X128: aom_superblock_size = 1;
#[doc = "< Select superblock size dynamically."]
pub const AOM_SUPERBLOCK_SIZE_DYNAMIC: aom_superblock_size = 2;
#[doc = "\\brief Superblock size selection."]
#[doc = ""]
#[doc = " Defines the superblock size used for encoding. The superblock size can"]
#[doc = " either be fixed at 64x64 or 128x128 pixels, or it can be dynamically"]
#[doc = " selected by the encoder for each frame."]
pub type aom_superblock_size = ::std::os::raw::c_uint;
#[doc = "\\brief Superblock size selection."]
#[doc = ""]
#[doc = " Defines the superblock size used for encoding. The superblock size can"]
#[doc = " either be fixed at 64x64 or 128x128 pixels, or it can be dynamically"]
#[doc = " selected by the encoder for each frame."]
pub use self::aom_superblock_size as aom_superblock_size_t;
extern "C" {
    #[doc = "\\brief Return the version information (as an integer)"]
    #[doc = ""]
    #[doc = " Returns a packed encoding of the library version number. This will only"]
    #[doc = " include"]
    #[doc = " the major.minor.patch component of the version number. Note that this encoded"]
    #[doc = " value should be accessed through the macros provided, as the encoding may"]
    #[doc = " change"]
    #[doc = " in the future."]
    #[doc = ""]
    pub fn aom_codec_version() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Return the version information (as a string)"]
    #[doc = ""]
    #[doc = " Returns a printable string containing the full library version number. This"]
    #[doc = " may"]
    #[doc = " contain additional text following the three digit version number, as to"]
    #[doc = " indicate"]
    #[doc = " release candidates, prerelease versions, etc."]
    #[doc = ""]
    pub fn aom_codec_version_str() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Return the version information (as a string)"]
    #[doc = ""]
    #[doc = " Returns a printable \"extra string\". This is the component of the string"]
    #[doc = " returned"]
    #[doc = " by aom_codec_version_str() following the three digit version number."]
    #[doc = ""]
    pub fn aom_codec_version_extra_str() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Return the build configuration"]
    #[doc = ""]
    #[doc = " Returns a printable string containing an encoded version of the build"]
    #[doc = " configuration. This may be useful to aom support."]
    #[doc = ""]
    pub fn aom_codec_build_config() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Return the name for a given interface"]
    #[doc = ""]
    #[doc = " Returns a human readable string for name of the given codec interface."]
    #[doc = ""]
    #[doc = " \\param[in]    iface     Interface pointer"]
    #[doc = ""]
    pub fn aom_codec_iface_name(iface: *mut aom_codec_iface_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Convert error number to printable string"]
    #[doc = ""]
    #[doc = " Returns a human readable string for the last error returned by the"]
    #[doc = " algorithm. The returned error will be one line and will not contain"]
    #[doc = " any newline characters."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param[in]    err     Error number."]
    #[doc = ""]
    pub fn aom_codec_err_to_string(err: aom_codec_err_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Retrieve error synopsis for codec context"]
    #[doc = ""]
    #[doc = " Returns a human readable string for the last error returned by the"]
    #[doc = " algorithm. The returned error will be one line and will not contain"]
    #[doc = " any newline characters."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param[in]    ctx     Pointer to this instance's context."]
    #[doc = ""]
    pub fn aom_codec_error(ctx: *mut aom_codec_ctx_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Retrieve detailed error information for codec context"]
    #[doc = ""]
    #[doc = " Returns a human readable string providing detailed information about"]
    #[doc = " the last error."]
    #[doc = ""]
    #[doc = " \\param[in]    ctx     Pointer to this instance's context."]
    #[doc = ""]
    #[doc = " \\retval NULL"]
    #[doc = "     No detailed information is available."]
    pub fn aom_codec_error_detail(ctx: *mut aom_codec_ctx_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Destroy a codec instance"]
    #[doc = ""]
    #[doc = " Destroys a codec context, freeing any associated memory buffers."]
    #[doc = ""]
    #[doc = " \\param[in] ctx   Pointer to this instance's context"]
    #[doc = ""]
    #[doc = " \\retval #AOM_CODEC_OK"]
    #[doc = "     The codec algorithm initialized."]
    #[doc = " \\retval #AOM_CODEC_MEM_ERROR"]
    #[doc = "     Memory allocation failed."]
    pub fn aom_codec_destroy(ctx: *mut aom_codec_ctx_t) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "\\brief Get the capabilities of an algorithm."]
    #[doc = ""]
    #[doc = " Retrieves the capabilities bitfield from the algorithm's interface."]
    #[doc = ""]
    #[doc = " \\param[in] iface   Pointer to the algorithm interface"]
    #[doc = ""]
    pub fn aom_codec_get_caps(iface: *mut aom_codec_iface_t) -> aom_codec_caps_t;
}
extern "C" {
    #[doc = "\\brief Control algorithm"]
    #[doc = ""]
    #[doc = " This function is used to exchange algorithm specific data with the codec"]
    #[doc = " instance. This can be used to implement features specific to a particular"]
    #[doc = " algorithm."]
    #[doc = ""]
    #[doc = " This wrapper function dispatches the request to the helper function"]
    #[doc = " associated with the given ctrl_id. It tries to call this function"]
    #[doc = " transparently, but will return #AOM_CODEC_ERROR if the request could not"]
    #[doc = " be dispatched."]
    #[doc = ""]
    #[doc = " Note that this function should not be used directly. Call the"]
    #[doc = " #aom_codec_control wrapper macro instead."]
    #[doc = ""]
    #[doc = " \\param[in]     ctx              Pointer to this instance's context"]
    #[doc = " \\param[in]     ctrl_id          Algorithm specific control identifier"]
    #[doc = ""]
    #[doc = " \\retval #AOM_CODEC_OK"]
    #[doc = "     The control request was processed."]
    #[doc = " \\retval #AOM_CODEC_ERROR"]
    #[doc = "     The control request was not processed."]
    #[doc = " \\retval #AOM_CODEC_INVALID_PARAM"]
    #[doc = "     The data was not valid."]
    pub fn aom_codec_control_(
        ctx: *mut aom_codec_ctx_t,
        ctrl_id: ::std::os::raw::c_int,
        ...
    ) -> aom_codec_err_t;
}
pub const OBU_SEQUENCE_HEADER: OBU_TYPE = 1;
pub const OBU_TEMPORAL_DELIMITER: OBU_TYPE = 2;
pub const OBU_FRAME_HEADER: OBU_TYPE = 3;
pub const OBU_TILE_GROUP: OBU_TYPE = 4;
pub const OBU_METADATA: OBU_TYPE = 5;
pub const OBU_FRAME: OBU_TYPE = 6;
pub const OBU_REDUNDANT_FRAME_HEADER: OBU_TYPE = 7;
pub const OBU_TILE_LIST: OBU_TYPE = 8;
pub const OBU_PADDING: OBU_TYPE = 15;
#[doc = "\\brief OBU types."]
pub type OBU_TYPE = ::std::os::raw::c_uchar;
pub const OBU_METADATA_TYPE_AOM_RESERVED_0: OBU_METADATA_TYPE = 0;
pub const OBU_METADATA_TYPE_HDR_CLL: OBU_METADATA_TYPE = 1;
pub const OBU_METADATA_TYPE_HDR_MDCV: OBU_METADATA_TYPE = 2;
pub const OBU_METADATA_TYPE_SCALABILITY: OBU_METADATA_TYPE = 3;
pub const OBU_METADATA_TYPE_ITUT_T35: OBU_METADATA_TYPE = 4;
pub const OBU_METADATA_TYPE_TIMECODE: OBU_METADATA_TYPE = 5;
#[doc = "\\brief OBU metadata types."]
pub type OBU_METADATA_TYPE = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "\\brief Returns string representation of OBU_TYPE."]
    #[doc = ""]
    #[doc = " \\param[in]     type            The OBU_TYPE to convert to string."]
    pub fn aom_obu_type_to_string(type_: OBU_TYPE) -> *const ::std::os::raw::c_char;
}
#[doc = "\\brief Config Options"]
#[doc = ""]
#[doc = " This type allows to enumerate and control options defined for control"]
#[doc = " via config file at runtime."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cfg_options {
    #[doc = "\\brief Reflects if ext_partition should be enabled"]
    #[doc = ""]
    #[doc = " If this value is non-zero it enabled the feature"]
    pub ext_partition: ::std::os::raw::c_uint,
}
#[doc = "\\brief Config Options"]
#[doc = ""]
#[doc = " This type allows to enumerate and control options defined for control"]
#[doc = " via config file at runtime."]
pub type cfg_options_t = cfg_options;
#[doc = "< set the decoder's post processing settings"]
pub const AOM_SET_POSTPROC: aom_com_control_id = 3;
pub const AOM_SET_DBG_COLOR_REF_FRAME: aom_com_control_id = 4;
#[doc = "< set which macro block modes to color"]
pub const AOM_SET_DBG_COLOR_MB_MODES: aom_com_control_id = 5;
#[doc = "< set which blocks modes to color"]
pub const AOM_SET_DBG_COLOR_B_MODES: aom_com_control_id = 6;
#[doc = "< set which motion vector modes to draw"]
pub const AOM_SET_DBG_DISPLAY_MV: aom_com_control_id = 7;
#[doc = "< get a pointer to a reference frame"]
pub const AV1_GET_REFERENCE: aom_com_control_id = 128;
#[doc = "< write a frame into a reference buffer"]
pub const AV1_SET_REFERENCE: aom_com_control_id = 129;
pub const AV1_COPY_REFERENCE: aom_com_control_id = 130;
pub const AOM_COMMON_CTRL_ID_MAX: aom_com_control_id = 131;
#[doc = "< get a pointer to the new frame"]
pub const AV1_GET_NEW_FRAME_IMAGE: aom_com_control_id = 192;
pub const AV1_COPY_NEW_FRAME_IMAGE: aom_com_control_id = 193;
pub const AOM_DECODER_CTRL_ID_START: aom_com_control_id = 256;
#[doc = "\\brief Control functions"]
#[doc = ""]
#[doc = " The set of macros define the control functions of AOM interface"]
pub type aom_com_control_id = ::std::os::raw::c_uint;
pub const AOM_NOFILTERING: aom_postproc_level = 0;
pub const AOM_DEBLOCK: aom_postproc_level = 1;
pub const AOM_DEMACROBLOCK: aom_postproc_level = 2;
pub const AOM_ADDNOISE: aom_postproc_level = 4;
#[doc = "< print frame information"]
pub const AOM_DEBUG_TXT_FRAME_INFO: aom_postproc_level = 8;
pub const AOM_DEBUG_TXT_MBLK_MODES: aom_postproc_level = 16;
#[doc = "< print dc diff for each macro block"]
pub const AOM_DEBUG_TXT_DC_DIFF: aom_postproc_level = 32;
#[doc = "< print video rate info (encoder only)"]
pub const AOM_DEBUG_TXT_RATE_INFO: aom_postproc_level = 64;
pub const AOM_MFQE: aom_postproc_level = 1024;
#[doc = "\\brief post process flags"]
#[doc = ""]
#[doc = " The set of macros define AOM decoder post processing flags"]
pub type aom_postproc_level = ::std::os::raw::c_uint;
#[doc = "\\brief post process flags"]
#[doc = ""]
#[doc = " This define a structure that describe the post processing settings. For"]
#[doc = " the best objective measure (using the PSNR metric) set post_proc_flag"]
#[doc = " to AOM_DEBLOCK and deblocking_level to 1."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_postproc_cfg {
    #[doc = "\\brief the types of post processing to be done, should be combination of"]
    #[doc = " \"aom_postproc_level\""]
    pub post_proc_flag: ::std::os::raw::c_int,
    #[doc = "< the strength of deblocking, valid range [0, 16]"]
    pub deblocking_level: ::std::os::raw::c_int,
    #[doc = "< the strength of additive noise, valid range [0, 16]"]
    pub noise_level: ::std::os::raw::c_int,
}
#[doc = "\\brief post process flags"]
#[doc = ""]
#[doc = " This define a structure that describe the post processing settings. For"]
#[doc = " the best objective measure (using the PSNR metric) set post_proc_flag"]
#[doc = " to AOM_DEBLOCK and deblocking_level to 1."]
pub type aom_postproc_cfg_t = aom_postproc_cfg;
#[doc = "\\brief AV1 specific reference frame data struct"]
#[doc = ""]
#[doc = " Define the data struct to access av1 reference frames."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct av1_ref_frame {
    #[doc = "< frame index to get (input)"]
    pub idx: ::std::os::raw::c_int,
    #[doc = "< Directly use external ref buffer(decoder only)"]
    pub use_external_ref: ::std::os::raw::c_int,
    #[doc = "< img structure to populate (output)"]
    pub img: aom_image_t,
}
#[doc = "\\brief AV1 specific reference frame data struct"]
#[doc = ""]
#[doc = " Define the data struct to access av1 reference frames."]
pub type av1_ref_frame_t = av1_ref_frame;
#[doc = "\\brief Generic fixed size buffer structure"]
#[doc = ""]
#[doc = " This structure is able to hold a reference to any fixed size buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_fixed_buf {
    #[doc = "< Pointer to the data. Does NOT own the data!"]
    pub buf: *mut ::std::os::raw::c_void,
    #[doc = "< Length of the buffer, in chars"]
    pub sz: usize,
}
#[doc = "\\brief Generic fixed size buffer structure"]
#[doc = ""]
#[doc = " This structure is able to hold a reference to any fixed size buffer."]
pub type aom_fixed_buf_t = aom_fixed_buf;
#[doc = "\\brief Time Stamp Type"]
#[doc = ""]
#[doc = " An integer, which when multiplied by the stream's time base, provides"]
#[doc = " the absolute time of a sample."]
pub type aom_codec_pts_t = i64;
#[doc = "\\brief Compressed Frame Flags"]
#[doc = ""]
#[doc = " This type represents a bitfield containing information about a compressed"]
#[doc = " frame that may be useful to an application. The most significant 16 bits"]
#[doc = " can be used by an algorithm to provide additional detail, for example to"]
#[doc = " support frame types that are codec specific (MPEG-1 D-frames for example)"]
pub type aom_codec_frame_flags_t = u32;
#[doc = "\\brief Error Resilient flags"]
#[doc = ""]
#[doc = " These flags define which error resilient features to enable in the"]
#[doc = " encoder. The flags are specified through the"]
#[doc = " aom_codec_enc_cfg::g_error_resilient variable."]
pub type aom_codec_er_flags_t = u32;
#[doc = "< Compressed video frame"]
pub const AOM_CODEC_CX_FRAME_PKT: aom_codec_cx_pkt_kind = 0;
#[doc = "< Two-pass statistics for this frame"]
pub const AOM_CODEC_STATS_PKT: aom_codec_cx_pkt_kind = 1;
#[doc = "< first pass mb statistics for this frame"]
pub const AOM_CODEC_FPMB_STATS_PKT: aom_codec_cx_pkt_kind = 2;
#[doc = "< PSNR statistics for this frame"]
pub const AOM_CODEC_PSNR_PKT: aom_codec_cx_pkt_kind = 3;
#[doc = "< Algorithm extensions"]
pub const AOM_CODEC_CUSTOM_PKT: aom_codec_cx_pkt_kind = 256;
#[doc = "\\brief Encoder output packet variants"]
#[doc = ""]
#[doc = " This enumeration lists the different kinds of data packets that can be"]
#[doc = " returned by calls to aom_codec_get_cx_data(). Algorithms \\ref MAY"]
#[doc = " extend this list to provide additional functionality."]
pub type aom_codec_cx_pkt_kind = ::std::os::raw::c_uint;
#[doc = "\\brief Encoder output packet"]
#[doc = ""]
#[doc = " This structure contains the different kinds of output data the encoder"]
#[doc = " may produce while compressing a frame."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aom_codec_cx_pkt {
    #[doc = "< packet variant"]
    pub kind: aom_codec_cx_pkt_kind,
    #[doc = "< packet data"]
    pub data: aom_codec_cx_pkt__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union aom_codec_cx_pkt__bindgen_ty_1 {
    #[doc = "< data for compressed frame packet"]
    pub frame: aom_codec_cx_pkt__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< data for two-pass packet"]
    pub twopass_stats: aom_fixed_buf_t,
    #[doc = "< first pass mb packet"]
    pub firstpass_mb_stats: aom_fixed_buf_t,
    #[doc = "< data for PSNR packet"]
    pub psnr: aom_codec_cx_pkt__bindgen_ty_1_aom_psnr_pkt,
    #[doc = "< data for arbitrary packets"]
    pub raw: aom_fixed_buf_t,
    #[doc = "< fixed sz"]
    pub pad: [::std::os::raw::c_char; 124usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_codec_cx_pkt__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< compressed data buffer"]
    pub buf: *mut ::std::os::raw::c_void,
    #[doc = "< length of compressed data"]
    pub sz: usize,
    #[doc = "\\brief time stamp to show frame (in timebase units)"]
    pub pts: aom_codec_pts_t,
    #[doc = "\\brief duration to show frame (in timebase units)"]
    pub duration: ::std::os::raw::c_ulong,
    #[doc = "< flags for this frame"]
    pub flags: aom_codec_frame_flags_t,
    #[doc = "\\brief the partition id defines the decoding order of the partitions."]
    #[doc = " Only applicable when \"output partition\" mode is enabled. First"]
    #[doc = " partition has id 0."]
    pub partition_id: ::std::os::raw::c_int,
    #[doc = "\\brief size of the visible frame in this packet"]
    pub vis_frame_size: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_codec_cx_pkt__bindgen_ty_1_aom_psnr_pkt {
    #[doc = "< Number of samples, total/y/u/v"]
    pub samples: [::std::os::raw::c_uint; 4usize],
    #[doc = "< sum squared error, total/y/u/v"]
    pub sse: [u64; 4usize],
    #[doc = "< PSNR, total/y/u/v"]
    pub psnr: [f64; 4usize],
}
#[doc = "\\brief Encoder output packet"]
#[doc = ""]
#[doc = " This structure contains the different kinds of output data the encoder"]
#[doc = " may produce while compressing a frame."]
pub type aom_codec_cx_pkt_t = aom_codec_cx_pkt;
#[doc = "\\brief Rational Number"]
#[doc = ""]
#[doc = " This structure holds a fractional value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_rational {
    #[doc = "< fraction numerator"]
    pub num: ::std::os::raw::c_int,
    #[doc = "< fraction denominator"]
    pub den: ::std::os::raw::c_int,
}
#[doc = "\\brief Rational Number"]
#[doc = ""]
#[doc = " This structure holds a fractional value."]
pub type aom_rational_t = aom_rational;
#[doc = "< Single pass mode"]
pub const AOM_RC_ONE_PASS: aom_enc_pass = 0;
#[doc = "< First pass of multi-pass mode"]
pub const AOM_RC_FIRST_PASS: aom_enc_pass = 1;
#[doc = "< Final pass of multi-pass mode"]
pub const AOM_RC_LAST_PASS: aom_enc_pass = 2;
#[doc = "\\brief Multi-pass Encoding Pass"]
pub type aom_enc_pass = ::std::os::raw::c_uint;
#[doc = "< Variable Bit Rate (VBR) mode"]
pub const AOM_VBR: aom_rc_mode = 0;
#[doc = "< Constant Bit Rate (CBR) mode"]
pub const AOM_CBR: aom_rc_mode = 1;
#[doc = "< Constrained Quality (CQ)  mode"]
pub const AOM_CQ: aom_rc_mode = 2;
#[doc = "< Constant Quality (Q) mode"]
pub const AOM_Q: aom_rc_mode = 3;
#[doc = "\\brief Rate control mode"]
pub type aom_rc_mode = ::std::os::raw::c_uint;
#[doc = "< deprecated, implies AOM_KF_DISABLED"]
pub const AOM_KF_FIXED: aom_kf_mode = 0;
#[doc = "< Encoder determines optimal placement automatically"]
pub const AOM_KF_AUTO: aom_kf_mode = 1;
#[doc = "< Encoder does not place keyframes."]
pub const AOM_KF_DISABLED: aom_kf_mode = 0;
#[doc = "\\brief Keyframe placement mode."]
#[doc = ""]
#[doc = " This enumeration determines whether keyframes are placed automatically by"]
#[doc = " the encoder or whether this behavior is disabled. Older releases of this"]
#[doc = " SDK were implemented such that AOM_KF_FIXED meant keyframes were disabled."]
#[doc = " This name is confusing for this behavior, so the new symbols to be used"]
#[doc = " are AOM_KF_AUTO and AOM_KF_DISABLED."]
pub type aom_kf_mode = ::std::os::raw::c_uint;
#[doc = "\\brief Encoded Frame Flags"]
#[doc = ""]
#[doc = " This type indicates a bitfield to be passed to aom_codec_encode(), defining"]
#[doc = " per-frame boolean values. By convention, bits common to all codecs will be"]
#[doc = " named AOM_EFLAG_*, and bits specific to an algorithm will be named"]
#[doc = " /algo/_eflag_*. The lower order 16 bits are reserved for common use."]
pub type aom_enc_frame_flags_t = ::std::os::raw::c_long;
#[doc = "\\brief Encoder configuration structure"]
#[doc = ""]
#[doc = " This structure contains the encoder settings that have common representations"]
#[doc = " across all codecs. This doesn't imply that all codecs support all features,"]
#[doc = " however."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_codec_enc_cfg {
    #[doc = "\\brief Algorithm specific \"usage\" value"]
    #[doc = ""]
    #[doc = " Algorithms may define multiple values for usage, which may convey the"]
    #[doc = " intent of how the application intends to use the stream. If this value"]
    #[doc = " is non-zero, consult the documentation for the codec to determine its"]
    #[doc = " meaning."]
    pub g_usage: ::std::os::raw::c_uint,
    #[doc = "\\brief Maximum number of threads to use"]
    #[doc = ""]
    #[doc = " For multi-threaded implementations, use no more than this number of"]
    #[doc = " threads. The codec may use fewer threads than allowed. The value"]
    #[doc = " 0 is equivalent to the value 1."]
    pub g_threads: ::std::os::raw::c_uint,
    #[doc = "< profile of bitstream to use"]
    pub g_profile: ::std::os::raw::c_uint,
    #[doc = "\\brief Width of the frame"]
    #[doc = ""]
    #[doc = " This value identifies the presentation resolution of the frame,"]
    #[doc = " in pixels. Note that the frames passed as input to the encoder must"]
    #[doc = " have this resolution. Frames will be presented by the decoder in this"]
    #[doc = " resolution, independent of any spatial resampling the encoder may do."]
    pub g_w: ::std::os::raw::c_uint,
    #[doc = "\\brief Height of the frame"]
    #[doc = ""]
    #[doc = " This value identifies the presentation resolution of the frame,"]
    #[doc = " in pixels. Note that the frames passed as input to the encoder must"]
    #[doc = " have this resolution. Frames will be presented by the decoder in this"]
    #[doc = " resolution, independent of any spatial resampling the encoder may do."]
    pub g_h: ::std::os::raw::c_uint,
    #[doc = "\\brief Max number of frames to encode"]
    #[doc = ""]
    pub g_limit: ::std::os::raw::c_uint,
    #[doc = "\\brief Forced maximum width of the frame"]
    #[doc = ""]
    #[doc = " If this value is non-zero then it is used to force the maximum frame"]
    #[doc = " width written in write_sequence_header()."]
    pub g_forced_max_frame_width: ::std::os::raw::c_uint,
    #[doc = "\\brief Forced maximum height of the frame"]
    #[doc = ""]
    #[doc = " If this value is non-zero then it is used to force the maximum frame"]
    #[doc = " height written in write_sequence_header()."]
    pub g_forced_max_frame_height: ::std::os::raw::c_uint,
    #[doc = "\\brief Bit-depth of the codec"]
    #[doc = ""]
    #[doc = " This value identifies the bit_depth of the codec,"]
    #[doc = " Only certain bit-depths are supported as identified in the"]
    #[doc = " aom_bit_depth_t enum."]
    pub g_bit_depth: aom_bit_depth_t,
    #[doc = "\\brief Bit-depth of the input frames"]
    #[doc = ""]
    #[doc = " This value identifies the bit_depth of the input frames in bits."]
    #[doc = " Note that the frames passed as input to the encoder must have"]
    #[doc = " this bit-depth."]
    pub g_input_bit_depth: ::std::os::raw::c_uint,
    #[doc = "\\brief Stream timebase units"]
    #[doc = ""]
    #[doc = " Indicates the smallest interval of time, in seconds, used by the stream."]
    #[doc = " For fixed frame rate material, or variable frame rate material where"]
    #[doc = " frames are timed at a multiple of a given clock (ex: video capture),"]
    #[doc = " the \\ref RECOMMENDED method is to set the timebase to the reciprocal"]
    #[doc = " of the frame rate (ex: 1001/30000 for 29.970 Hz NTSC). This allows the"]
    #[doc = " pts to correspond to the frame number, which can be handy. For"]
    #[doc = " re-encoding video from containers with absolute time timestamps, the"]
    #[doc = " \\ref RECOMMENDED method is to set the timebase to that of the parent"]
    #[doc = " container or multimedia framework (ex: 1/1000 for ms, as in FLV)."]
    pub g_timebase: aom_rational,
    #[doc = "\\brief Enable error resilient modes."]
    #[doc = ""]
    #[doc = " The error resilient bitfield indicates to the encoder which features"]
    #[doc = " it should enable to take measures for streaming over lossy or noisy"]
    #[doc = " links."]
    pub g_error_resilient: aom_codec_er_flags_t,
    #[doc = "\\brief Multi-pass Encoding Mode"]
    #[doc = ""]
    #[doc = " This value should be set to the current phase for multi-pass encoding."]
    #[doc = " For single pass, set to #AOM_RC_ONE_PASS."]
    pub g_pass: aom_enc_pass,
    #[doc = "\\brief Allow lagged encoding"]
    #[doc = ""]
    #[doc = " If set, this value allows the encoder to consume a number of input"]
    #[doc = " frames before producing output frames. This allows the encoder to"]
    #[doc = " base decisions for the current frame on future frames. This does"]
    #[doc = " increase the latency of the encoding pipeline, so it is not appropriate"]
    #[doc = " in all situations (ex: realtime encoding)."]
    #[doc = ""]
    #[doc = " Note that this is a maximum value -- the encoder may produce frames"]
    #[doc = " sooner than the given limit. Set this value to 0 to disable this"]
    #[doc = " feature."]
    pub g_lag_in_frames: ::std::os::raw::c_uint,
    #[doc = "\\brief Temporal resampling configuration, if supported by the codec."]
    #[doc = ""]
    #[doc = " Temporal resampling allows the codec to \"drop\" frames as a strategy to"]
    #[doc = " meet its target data rate. This can cause temporal discontinuities in"]
    #[doc = " the encoded video, which may appear as stuttering during playback. This"]
    #[doc = " trade-off is often acceptable, but for many applications is not. It can"]
    #[doc = " be disabled in these cases."]
    #[doc = ""]
    #[doc = " Note that not all codecs support this feature. All aom AVx codecs do."]
    #[doc = " For other codecs, consult the documentation for that algorithm."]
    #[doc = ""]
    #[doc = " This threshold is described as a percentage of the target data buffer."]
    #[doc = " When the data buffer falls below this percentage of fullness, a"]
    #[doc = " dropped frame is indicated. Set the threshold to zero (0) to disable"]
    #[doc = " this feature."]
    pub rc_dropframe_thresh: ::std::os::raw::c_uint,
    #[doc = "\\brief Mode for spatial resampling, if supported by the codec."]
    #[doc = ""]
    #[doc = " Spatial resampling allows the codec to compress a lower resolution"]
    #[doc = " version of the frame, which is then upscaled by the decoder to the"]
    #[doc = " correct presentation resolution. This increases visual quality at"]
    #[doc = " low data rates, at the expense of CPU time on the encoder/decoder."]
    pub rc_resize_mode: ::std::os::raw::c_uint,
    #[doc = "\\brief Frame resize denominator."]
    #[doc = ""]
    #[doc = " The denominator for resize to use, assuming 8 as the numerator."]
    #[doc = ""]
    #[doc = " Valid denominators are  8 - 16 for now."]
    pub rc_resize_denominator: ::std::os::raw::c_uint,
    #[doc = "\\brief Keyframe resize denominator."]
    #[doc = ""]
    #[doc = " The denominator for resize to use, assuming 8 as the numerator."]
    #[doc = ""]
    #[doc = " Valid denominators are  8 - 16 for now."]
    pub rc_resize_kf_denominator: ::std::os::raw::c_uint,
    #[doc = "\\brief Frame super-resolution scaling mode."]
    #[doc = ""]
    #[doc = " Similar to spatial resampling, frame super-resolution integrates"]
    #[doc = " upscaling after the encode/decode process. Taking control of upscaling and"]
    #[doc = " using restoration filters should allow it to outperform normal resizing."]
    #[doc = ""]
    #[doc = " Valid values are 0 to 4 as defined in enum SUPERRES_MODE."]
    pub rc_superres_mode: ::std::os::raw::c_uint,
    #[doc = "\\brief Frame super-resolution denominator."]
    #[doc = ""]
    #[doc = " The denominator for superres to use. If fixed it will only change if the"]
    #[doc = " cumulative scale change over resizing and superres is greater than 1/2;"]
    #[doc = " this forces superres to reduce scaling."]
    #[doc = ""]
    #[doc = " Valid denominators are 8 to 16."]
    #[doc = ""]
    #[doc = " Used only by SUPERRES_FIXED."]
    pub rc_superres_denominator: ::std::os::raw::c_uint,
    #[doc = "\\brief Keyframe super-resolution denominator."]
    #[doc = ""]
    #[doc = " The denominator for superres to use. If fixed it will only change if the"]
    #[doc = " cumulative scale change over resizing and superres is greater than 1/2;"]
    #[doc = " this forces superres to reduce scaling."]
    #[doc = ""]
    #[doc = " Valid denominators are 8 - 16 for now."]
    pub rc_superres_kf_denominator: ::std::os::raw::c_uint,
    #[doc = "\\brief Frame super-resolution q threshold."]
    #[doc = ""]
    #[doc = " The q level threshold after which superres is used."]
    #[doc = " Valid values are 1 to 63."]
    #[doc = ""]
    #[doc = " Used only by SUPERRES_QTHRESH"]
    pub rc_superres_qthresh: ::std::os::raw::c_uint,
    #[doc = "\\brief Keyframe super-resolution q threshold."]
    #[doc = ""]
    #[doc = " The q level threshold after which superres is used for key frames."]
    #[doc = " Valid values are 1 to 63."]
    #[doc = ""]
    #[doc = " Used only by SUPERRES_QTHRESH"]
    pub rc_superres_kf_qthresh: ::std::os::raw::c_uint,
    #[doc = "\\brief Rate control algorithm to use."]
    #[doc = ""]
    #[doc = " Indicates whether the end usage of this stream is to be streamed over"]
    #[doc = " a bandwidth constrained link, indicating that Constant Bit Rate (CBR)"]
    #[doc = " mode should be used, or whether it will be played back on a high"]
    #[doc = " bandwidth link, as from a local disk, where higher variations in"]
    #[doc = " bitrate are acceptable."]
    pub rc_end_usage: aom_rc_mode,
    #[doc = "\\brief Two-pass stats buffer."]
    #[doc = ""]
    #[doc = " A buffer containing all of the stats packets produced in the first"]
    #[doc = " pass, concatenated."]
    pub rc_twopass_stats_in: aom_fixed_buf_t,
    #[doc = "\\brief first pass mb stats buffer."]
    #[doc = ""]
    #[doc = " A buffer containing all of the first pass mb stats packets produced"]
    #[doc = " in the first pass, concatenated."]
    pub rc_firstpass_mb_stats_in: aom_fixed_buf_t,
    #[doc = "\\brief Target data rate"]
    #[doc = ""]
    #[doc = " Target bandwidth to use for this stream, in kilobits per second."]
    pub rc_target_bitrate: ::std::os::raw::c_uint,
    #[doc = "\\brief Minimum (Best Quality) Quantizer"]
    #[doc = ""]
    #[doc = " The quantizer is the most direct control over the quality of the"]
    #[doc = " encoded image. The range of valid values for the quantizer is codec"]
    #[doc = " specific. Consult the documentation for the codec to determine the"]
    #[doc = " values to use. To determine the range programmatically, call"]
    #[doc = " aom_codec_enc_config_default() with a usage value of 0."]
    pub rc_min_quantizer: ::std::os::raw::c_uint,
    #[doc = "\\brief Maximum (Worst Quality) Quantizer"]
    #[doc = ""]
    #[doc = " The quantizer is the most direct control over the quality of the"]
    #[doc = " encoded image. The range of valid values for the quantizer is codec"]
    #[doc = " specific. Consult the documentation for the codec to determine the"]
    #[doc = " values to use. To determine the range programmatically, call"]
    #[doc = " aom_codec_enc_config_default() with a usage value of 0."]
    pub rc_max_quantizer: ::std::os::raw::c_uint,
    #[doc = "\\brief Rate control adaptation undershoot control"]
    #[doc = ""]
    #[doc = " This value, expressed as a percentage of the target bitrate,"]
    #[doc = " controls the maximum allowed adaptation speed of the codec."]
    #[doc = " This factor controls the maximum amount of bits that can"]
    #[doc = " be subtracted from the target bitrate in order to compensate"]
    #[doc = " for prior overshoot."]
    #[doc = ""]
    #[doc = " Valid values in the range 0-1000."]
    pub rc_undershoot_pct: ::std::os::raw::c_uint,
    #[doc = "\\brief Rate control adaptation overshoot control"]
    #[doc = ""]
    #[doc = " This value, expressed as a percentage of the target bitrate,"]
    #[doc = " controls the maximum allowed adaptation speed of the codec."]
    #[doc = " This factor controls the maximum amount of bits that can"]
    #[doc = " be added to the target bitrate in order to compensate for"]
    #[doc = " prior undershoot."]
    #[doc = ""]
    #[doc = " Valid values in the range 0-1000."]
    pub rc_overshoot_pct: ::std::os::raw::c_uint,
    #[doc = "\\brief Decoder Buffer Size"]
    #[doc = ""]
    #[doc = " This value indicates the amount of data that may be buffered by the"]
    #[doc = " decoding application. Note that this value is expressed in units of"]
    #[doc = " time (milliseconds). For example, a value of 5000 indicates that the"]
    #[doc = " client will buffer (at least) 5000ms worth of encoded data. Use the"]
    #[doc = " target bitrate (#rc_target_bitrate) to convert to bits/bytes, if"]
    #[doc = " necessary."]
    pub rc_buf_sz: ::std::os::raw::c_uint,
    #[doc = "\\brief Decoder Buffer Initial Size"]
    #[doc = ""]
    #[doc = " This value indicates the amount of data that will be buffered by the"]
    #[doc = " decoding application prior to beginning playback. This value is"]
    #[doc = " expressed in units of time (milliseconds). Use the target bitrate"]
    #[doc = " (#rc_target_bitrate) to convert to bits/bytes, if necessary."]
    pub rc_buf_initial_sz: ::std::os::raw::c_uint,
    #[doc = "\\brief Decoder Buffer Optimal Size"]
    #[doc = ""]
    #[doc = " This value indicates the amount of data that the encoder should try"]
    #[doc = " to maintain in the decoder's buffer. This value is expressed in units"]
    #[doc = " of time (milliseconds). Use the target bitrate (#rc_target_bitrate)"]
    #[doc = " to convert to bits/bytes, if necessary."]
    pub rc_buf_optimal_sz: ::std::os::raw::c_uint,
    #[doc = "\\brief Two-pass mode CBR/VBR bias"]
    #[doc = ""]
    #[doc = " Bias, expressed on a scale of 0 to 100, for determining target size"]
    #[doc = " for the current frame. The value 0 indicates the optimal CBR mode"]
    #[doc = " value should be used. The value 100 indicates the optimal VBR mode"]
    #[doc = " value should be used. Values in between indicate which way the"]
    #[doc = " encoder should \"lean.\""]
    pub rc_2pass_vbr_bias_pct: ::std::os::raw::c_uint,
    #[doc = "\\brief Two-pass mode per-GOP minimum bitrate"]
    #[doc = ""]
    #[doc = " This value, expressed as a percentage of the target bitrate, indicates"]
    #[doc = " the minimum bitrate to be used for a single GOP (aka \"section\")"]
    pub rc_2pass_vbr_minsection_pct: ::std::os::raw::c_uint,
    #[doc = "\\brief Two-pass mode per-GOP maximum bitrate"]
    #[doc = ""]
    #[doc = " This value, expressed as a percentage of the target bitrate, indicates"]
    #[doc = " the maximum bitrate to be used for a single GOP (aka \"section\")"]
    pub rc_2pass_vbr_maxsection_pct: ::std::os::raw::c_uint,
    #[doc = "\\brief Option to enable forward reference key frame"]
    #[doc = ""]
    pub fwd_kf_enabled: ::std::os::raw::c_int,
    #[doc = "\\brief Keyframe placement mode"]
    #[doc = ""]
    #[doc = " This value indicates whether the encoder should place keyframes at a"]
    #[doc = " fixed interval, or determine the optimal placement automatically"]
    #[doc = " (as governed by the #kf_min_dist and #kf_max_dist parameters)"]
    pub kf_mode: aom_kf_mode,
    #[doc = "\\brief Keyframe minimum interval"]
    #[doc = ""]
    #[doc = " This value, expressed as a number of frames, prevents the encoder from"]
    #[doc = " placing a keyframe nearer than kf_min_dist to the previous keyframe. At"]
    #[doc = " least kf_min_dist frames non-keyframes will be coded before the next"]
    #[doc = " keyframe. Set kf_min_dist equal to kf_max_dist for a fixed interval."]
    pub kf_min_dist: ::std::os::raw::c_uint,
    #[doc = "\\brief Keyframe maximum interval"]
    #[doc = ""]
    #[doc = " This value, expressed as a number of frames, forces the encoder to code"]
    #[doc = " a keyframe if one has not been coded in the last kf_max_dist frames."]
    #[doc = " A value of 0 implies all frames will be keyframes. Set kf_min_dist"]
    #[doc = " equal to kf_max_dist for a fixed interval."]
    pub kf_max_dist: ::std::os::raw::c_uint,
    #[doc = "\\brief sframe interval"]
    #[doc = ""]
    #[doc = " This value, expressed as a number of frames, forces the encoder to code"]
    #[doc = " an S-Frame every sframe_dist frames."]
    pub sframe_dist: ::std::os::raw::c_uint,
    #[doc = "\\brief sframe insertion mode"]
    #[doc = ""]
    #[doc = " This value must be set to 1 or 2, and tells the encoder how to insert"]
    #[doc = " S-Frames. It will only have an effect if sframe_dist != 0."]
    #[doc = ""]
    #[doc = " If altref is enabled:"]
    #[doc = "   - if sframe_mode == 1, the considered frame will be made into an"]
    #[doc = "     S-Frame only if it is an altref frame"]
    #[doc = "   - if sframe_mode == 2, the next altref frame will be made into an"]
    #[doc = "     S-Frame."]
    #[doc = ""]
    #[doc = " Otherwise: the considered frame will be made into an S-Frame."]
    pub sframe_mode: ::std::os::raw::c_uint,
    #[doc = "\\brief Tile coding mode"]
    #[doc = ""]
    #[doc = " This value indicates the tile coding mode."]
    #[doc = " A value of 0 implies a normal non-large-scale tile coding. A value of 1"]
    #[doc = " implies a large-scale tile coding."]
    pub large_scale_tile: ::std::os::raw::c_uint,
    #[doc = "\\brief Monochrome mode"]
    #[doc = ""]
    #[doc = " If this is nonzero, the encoder will generate a monochrome stream"]
    #[doc = " with no chroma planes."]
    pub monochrome: ::std::os::raw::c_uint,
    #[doc = "\\brief full_still_picture_hdr"]
    #[doc = ""]
    #[doc = " If this is nonzero, the encoder will generate a full header even for"]
    #[doc = " still picture encoding. if zero, a reduced header is used for still"]
    #[doc = " picture. This flag has no effect when a regular video with more than"]
    #[doc = " a single frame is encoded."]
    pub full_still_picture_hdr: ::std::os::raw::c_uint,
    #[doc = "\\brief Bitstream syntax mode"]
    #[doc = ""]
    #[doc = " This value indicates the bitstream syntax mode."]
    #[doc = " A value of 0 indicates bitstream is saved as Section 5 bitstream. A value"]
    #[doc = " of 1 indicates the bitstream is saved in Annex-B format"]
    pub save_as_annexb: ::std::os::raw::c_uint,
    #[doc = "\\brief Number of explicit tile widths specified"]
    #[doc = ""]
    #[doc = " This value indicates the number of tile widths specified"]
    #[doc = " A value of 0 implies no tile widths are specified."]
    #[doc = " Tile widths are given in the array tile_widths[]"]
    pub tile_width_count: ::std::os::raw::c_int,
    #[doc = "\\brief Number of explicit tile heights specified"]
    #[doc = ""]
    #[doc = " This value indicates the number of tile heights specified"]
    #[doc = " A value of 0 implies no tile heights are specified."]
    #[doc = " Tile heights are given in the array tile_heights[]"]
    pub tile_height_count: ::std::os::raw::c_int,
    #[doc = "\\brief Array of specified tile widths"]
    #[doc = ""]
    #[doc = " This array specifies tile widths (and may be empty)"]
    #[doc = " The number of widths specified is given by tile_width_count"]
    pub tile_widths: [::std::os::raw::c_int; 64usize],
    #[doc = "\\brief Array of specified tile heights"]
    #[doc = ""]
    #[doc = " This array specifies tile heights (and may be empty)"]
    #[doc = " The number of heights specified is given by tile_height_count"]
    pub tile_heights: [::std::os::raw::c_int; 64usize],
    #[doc = "\\brief Options defined per config file"]
    #[doc = ""]
    pub cfg: cfg_options_t,
}
#[doc = "\\brief Encoder configuration structure"]
#[doc = ""]
#[doc = " This structure contains the encoder settings that have common representations"]
#[doc = " across all codecs. This doesn't imply that all codecs support all features,"]
#[doc = " however."]
pub type aom_codec_enc_cfg_t = aom_codec_enc_cfg;
extern "C" {
    #[doc = "\\brief Initialize an encoder instance"]
    #[doc = ""]
    #[doc = " Initializes a encoder context using the given interface. Applications"]
    #[doc = " should call the aom_codec_enc_init convenience macro instead of this"]
    #[doc = " function directly, to ensure that the ABI version number parameter"]
    #[doc = " is properly initialized."]
    #[doc = ""]
    #[doc = " If the library was configured with --disable-multithread, this call"]
    #[doc = " is not thread safe and should be guarded with a lock if being used"]
    #[doc = " in a multithreaded context."]
    #[doc = ""]
    #[doc = " \\param[in]    ctx     Pointer to this instance's context."]
    #[doc = " \\param[in]    iface   Pointer to the algorithm interface to use."]
    #[doc = " \\param[in]    cfg     Configuration to use, if known."]
    #[doc = " \\param[in]    flags   Bitfield of AOM_CODEC_USE_* flags"]
    #[doc = " \\param[in]    ver     ABI version number. Must be set to"]
    #[doc = "                       AOM_ENCODER_ABI_VERSION"]
    #[doc = " \\retval #AOM_CODEC_OK"]
    #[doc = "     The decoder algorithm initialized."]
    #[doc = " \\retval #AOM_CODEC_MEM_ERROR"]
    #[doc = "     Memory allocation failed."]
    pub fn aom_codec_enc_init_ver(
        ctx: *mut aom_codec_ctx_t,
        iface: *mut aom_codec_iface_t,
        cfg: *const aom_codec_enc_cfg_t,
        flags: aom_codec_flags_t,
        ver: ::std::os::raw::c_int,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "\\brief Initialize multi-encoder instance"]
    #[doc = ""]
    #[doc = " Initializes multi-encoder context using the given interface."]
    #[doc = " Applications should call the aom_codec_enc_init_multi convenience macro"]
    #[doc = " instead of this function directly, to ensure that the ABI version number"]
    #[doc = " parameter is properly initialized."]
    #[doc = ""]
    #[doc = " \\param[in]    ctx     Pointer to this instance's context."]
    #[doc = " \\param[in]    iface   Pointer to the algorithm interface to use."]
    #[doc = " \\param[in]    cfg     Configuration to use, if known."]
    #[doc = " \\param[in]    num_enc Total number of encoders."]
    #[doc = " \\param[in]    flags   Bitfield of AOM_CODEC_USE_* flags"]
    #[doc = " \\param[in]    dsf     Pointer to down-sampling factors."]
    #[doc = " \\param[in]    ver     ABI version number. Must be set to"]
    #[doc = "                       AOM_ENCODER_ABI_VERSION"]
    #[doc = " \\retval #AOM_CODEC_OK"]
    #[doc = "     The decoder algorithm initialized."]
    #[doc = " \\retval #AOM_CODEC_MEM_ERROR"]
    #[doc = "     Memory allocation failed."]
    pub fn aom_codec_enc_init_multi_ver(
        ctx: *mut aom_codec_ctx_t,
        iface: *mut aom_codec_iface_t,
        cfg: *mut aom_codec_enc_cfg_t,
        num_enc: ::std::os::raw::c_int,
        flags: aom_codec_flags_t,
        dsf: *mut aom_rational_t,
        ver: ::std::os::raw::c_int,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "\\brief Get a default configuration"]
    #[doc = ""]
    #[doc = " Initializes a encoder configuration structure with default values. Supports"]
    #[doc = " the notion of \"usages\" so that an algorithm may offer different default"]
    #[doc = " settings depending on the user's intended goal. This function \\ref SHOULD"]
    #[doc = " be called by all applications to initialize the configuration structure"]
    #[doc = " before specializing the configuration with application specific values."]
    #[doc = ""]
    #[doc = " \\param[in]    iface     Pointer to the algorithm interface to use."]
    #[doc = " \\param[out]   cfg       Configuration buffer to populate."]
    #[doc = " \\param[in]    reserved  Must set to 0."]
    #[doc = ""]
    #[doc = " \\retval #AOM_CODEC_OK"]
    #[doc = "     The configuration was populated."]
    #[doc = " \\retval #AOM_CODEC_INCAPABLE"]
    #[doc = "     Interface is not an encoder interface."]
    #[doc = " \\retval #AOM_CODEC_INVALID_PARAM"]
    #[doc = "     A parameter was NULL, or the usage value was not recognized."]
    pub fn aom_codec_enc_config_default(
        iface: *mut aom_codec_iface_t,
        cfg: *mut aom_codec_enc_cfg_t,
        reserved: ::std::os::raw::c_uint,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "\\brief Set or change configuration"]
    #[doc = ""]
    #[doc = " Reconfigures an encoder instance according to the given configuration."]
    #[doc = ""]
    #[doc = " \\param[in]    ctx     Pointer to this instance's context"]
    #[doc = " \\param[in]    cfg     Configuration buffer to use"]
    #[doc = ""]
    #[doc = " \\retval #AOM_CODEC_OK"]
    #[doc = "     The configuration was populated."]
    #[doc = " \\retval #AOM_CODEC_INCAPABLE"]
    #[doc = "     Interface is not an encoder interface."]
    #[doc = " \\retval #AOM_CODEC_INVALID_PARAM"]
    #[doc = "     A parameter was NULL, or the usage value was not recognized."]
    pub fn aom_codec_enc_config_set(
        ctx: *mut aom_codec_ctx_t,
        cfg: *const aom_codec_enc_cfg_t,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "\\brief Get global stream headers"]
    #[doc = ""]
    #[doc = " Retrieves a stream level global header packet, if supported by the codec."]
    #[doc = " Calls to this function should be deferred until all configuration information"]
    #[doc = " has been passed to libaom. Otherwise the global header data may be"]
    #[doc = " invalidated by additional configuration changes."]
    #[doc = ""]
    #[doc = " The AV1 implementation of this function returns an OBU. The OBU returned is"]
    #[doc = " in Low Overhead Bitstream Format. Specifically, the obu_has_size_field bit is"]
    #[doc = " set, and the buffer contains the obu_size field for the returned OBU."]
    #[doc = ""]
    #[doc = " \\param[in]    ctx     Pointer to this instance's context"]
    #[doc = ""]
    #[doc = " \\retval NULL"]
    #[doc = "     Encoder does not support global header, or an error occurred while"]
    #[doc = "     generating the global header."]
    #[doc = ""]
    #[doc = " \\retval Non-NULL"]
    #[doc = "     Pointer to buffer containing global header packet. The caller owns the"]
    #[doc = "     memory associated with this buffer, and must free the 'buf' member of the"]
    #[doc = "     aom_fixed_buf_t as well as the aom_fixed_buf_t pointer. Memory returned"]
    #[doc = "     must be freed via call to free()."]
    pub fn aom_codec_get_global_headers(ctx: *mut aom_codec_ctx_t) -> *mut aom_fixed_buf_t;
}
extern "C" {
    #[doc = "\\brief Encode a frame"]
    #[doc = ""]
    #[doc = " Encodes a video frame at the given \"presentation time.\" The presentation"]
    #[doc = " time stamp (PTS) \\ref MUST be strictly increasing."]
    #[doc = ""]
    #[doc = " When the last frame has been passed to the encoder, this function should"]
    #[doc = " continue to be called, with the img parameter set to NULL. This will"]
    #[doc = " signal the end-of-stream condition to the encoder and allow it to encode"]
    #[doc = " any held buffers. Encoding is complete when aom_codec_encode() is called"]
    #[doc = " and aom_codec_get_cx_data() returns no data."]
    #[doc = ""]
    #[doc = " \\param[in]    ctx       Pointer to this instance's context"]
    #[doc = " \\param[in]    img       Image data to encode, NULL to flush."]
    #[doc = " \\param[in]    pts       Presentation time stamp, in timebase units."]
    #[doc = " \\param[in]    duration  Duration to show frame, in timebase units."]
    #[doc = " \\param[in]    flags     Flags to use for encoding this frame."]
    #[doc = ""]
    #[doc = " \\retval #AOM_CODEC_OK"]
    #[doc = "     The configuration was populated."]
    #[doc = " \\retval #AOM_CODEC_INCAPABLE"]
    #[doc = "     Interface is not an encoder interface."]
    #[doc = " \\retval #AOM_CODEC_INVALID_PARAM"]
    #[doc = "     A parameter was NULL, the image format is unsupported, etc."]
    pub fn aom_codec_encode(
        ctx: *mut aom_codec_ctx_t,
        img: *const aom_image_t,
        pts: aom_codec_pts_t,
        duration: ::std::os::raw::c_ulong,
        flags: aom_enc_frame_flags_t,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "\\brief Set compressed data output buffer"]
    #[doc = ""]
    #[doc = " Sets the buffer that the codec should output the compressed data"]
    #[doc = " into. This call effectively sets the buffer pointer returned in the"]
    #[doc = " next AOM_CODEC_CX_FRAME_PKT packet. Subsequent packets will be"]
    #[doc = " appended into this buffer. The buffer is preserved across frames,"]
    #[doc = " so applications must periodically call this function after flushing"]
    #[doc = " the accumulated compressed data to disk or to the network to reset"]
    #[doc = " the pointer to the buffer's head."]
    #[doc = ""]
    #[doc = " `pad_before` bytes will be skipped before writing the compressed"]
    #[doc = " data, and `pad_after` bytes will be appended to the packet. The size"]
    #[doc = " of the packet will be the sum of the size of the actual compressed"]
    #[doc = " data, pad_before, and pad_after. The padding bytes will be preserved"]
    #[doc = " (not overwritten)."]
    #[doc = ""]
    #[doc = " Note that calling this function does not guarantee that the returned"]
    #[doc = " compressed data will be placed into the specified buffer. In the"]
    #[doc = " event that the encoded data will not fit into the buffer provided,"]
    #[doc = " the returned packet \\ref MAY point to an internal buffer, as it would"]
    #[doc = " if this call were never used. In this event, the output packet will"]
    #[doc = " NOT have any padding, and the application must free space and copy it"]
    #[doc = " to the proper place. This is of particular note in configurations"]
    #[doc = " that may output multiple packets for a single encoded frame (e.g., lagged"]
    #[doc = " encoding) or if the application does not reset the buffer periodically."]
    #[doc = ""]
    #[doc = " Applications may restore the default behavior of the codec providing"]
    #[doc = " the compressed data buffer by calling this function with a NULL"]
    #[doc = " buffer."]
    #[doc = ""]
    #[doc = " Applications \\ref MUSTNOT call this function during iteration of"]
    #[doc = " aom_codec_get_cx_data()."]
    #[doc = ""]
    #[doc = " \\param[in]    ctx         Pointer to this instance's context"]
    #[doc = " \\param[in]    buf         Buffer to store compressed data into"]
    #[doc = " \\param[in]    pad_before  Bytes to skip before writing compressed data"]
    #[doc = " \\param[in]    pad_after   Bytes to skip after writing compressed data"]
    #[doc = ""]
    #[doc = " \\retval #AOM_CODEC_OK"]
    #[doc = "     The buffer was set successfully."]
    #[doc = " \\retval #AOM_CODEC_INVALID_PARAM"]
    #[doc = "     A parameter was NULL, the image format is unsupported, etc."]
    pub fn aom_codec_set_cx_data_buf(
        ctx: *mut aom_codec_ctx_t,
        buf: *const aom_fixed_buf_t,
        pad_before: ::std::os::raw::c_uint,
        pad_after: ::std::os::raw::c_uint,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "\\brief Encoded data iterator"]
    #[doc = ""]
    #[doc = " Iterates over a list of data packets to be passed from the encoder to the"]
    #[doc = " application. The different kinds of packets available are enumerated in"]
    #[doc = " #aom_codec_cx_pkt_kind."]
    #[doc = ""]
    #[doc = " #AOM_CODEC_CX_FRAME_PKT packets should be passed to the application's"]
    #[doc = " muxer. Multiple compressed frames may be in the list."]
    #[doc = " #AOM_CODEC_STATS_PKT packets should be appended to a global buffer."]
    #[doc = ""]
    #[doc = " The application \\ref MUST silently ignore any packet kinds that it does"]
    #[doc = " not recognize or support."]
    #[doc = ""]
    #[doc = " The data buffers returned from this function are only guaranteed to be"]
    #[doc = " valid until the application makes another call to any aom_codec_* function."]
    #[doc = ""]
    #[doc = " \\param[in]     ctx      Pointer to this instance's context"]
    #[doc = " \\param[in,out] iter     Iterator storage, initialized to NULL"]
    #[doc = ""]
    #[doc = " \\return Returns a pointer to an output data packet (compressed frame data,"]
    #[doc = "         two-pass statistics, etc.) or NULL to signal end-of-list."]
    #[doc = ""]
    pub fn aom_codec_get_cx_data(
        ctx: *mut aom_codec_ctx_t,
        iter: *mut aom_codec_iter_t,
    ) -> *const aom_codec_cx_pkt_t;
}
extern "C" {
    #[doc = "\\brief Get Preview Frame"]
    #[doc = ""]
    #[doc = " Returns an image that can be used as a preview. Shows the image as it would"]
    #[doc = " exist at the decompressor. The application \\ref MUST NOT write into this"]
    #[doc = " image buffer."]
    #[doc = ""]
    #[doc = " \\param[in]     ctx      Pointer to this instance's context"]
    #[doc = ""]
    #[doc = " \\return Returns a pointer to a preview image, or NULL if no image is"]
    #[doc = "         available."]
    #[doc = ""]
    pub fn aom_codec_get_preview_frame(ctx: *mut aom_codec_ctx_t) -> *const aom_image_t;
}
#[doc = "\\brief External frame buffer"]
#[doc = ""]
#[doc = " This structure holds allocated frame buffers used by the decoder."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_codec_frame_buffer {
    #[doc = "< Pointer to the data buffer"]
    pub data: *mut u8,
    #[doc = "< Size of data in bytes"]
    pub size: usize,
    #[doc = "< Frame's private data"]
    pub priv_: *mut ::std::os::raw::c_void,
}
#[doc = "\\brief External frame buffer"]
#[doc = ""]
#[doc = " This structure holds allocated frame buffers used by the decoder."]
pub type aom_codec_frame_buffer_t = aom_codec_frame_buffer;
#[doc = "\\brief get frame buffer callback prototype"]
#[doc = ""]
#[doc = " This callback is invoked by the decoder to retrieve data for the frame"]
#[doc = " buffer in order for the decode call to complete. The callback must"]
#[doc = " allocate at least min_size in bytes and assign it to fb->data. The callback"]
#[doc = " must zero out all the data allocated. Then the callback must set fb->size"]
#[doc = " to the allocated size. The application does not need to align the allocated"]
#[doc = " data. The callback is triggered when the decoder needs a frame buffer to"]
#[doc = " decode a compressed image into. This function may be called more than once"]
#[doc = " for every call to aom_codec_decode. The application may set fb->priv to"]
#[doc = " some data which will be passed back in the aom_image_t and the release"]
#[doc = " function call. |fb| is guaranteed to not be NULL. On success the callback"]
#[doc = " must return 0. Any failure the callback must return a value less than 0."]
#[doc = ""]
#[doc = " \\param[in] priv         Callback's private data"]
#[doc = " \\param[in] new_size     Size in bytes needed by the buffer"]
#[doc = " \\param[in,out] fb       Pointer to aom_codec_frame_buffer_t"]
pub type aom_get_frame_buffer_cb_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        priv_: *mut ::std::os::raw::c_void,
        min_size: usize,
        fb: *mut aom_codec_frame_buffer_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = "\\brief release frame buffer callback prototype"]
#[doc = ""]
#[doc = " This callback is invoked by the decoder when the frame buffer is not"]
#[doc = " referenced by any other buffers. |fb| is guaranteed to not be NULL. On"]
#[doc = " success the callback must return 0. Any failure the callback must return"]
#[doc = " a value less than 0."]
#[doc = ""]
#[doc = " \\param[in] priv         Callback's private data"]
#[doc = " \\param[in] fb           Pointer to aom_codec_frame_buffer_t"]
pub type aom_release_frame_buffer_cb_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        priv_: *mut ::std::os::raw::c_void,
        fb: *mut aom_codec_frame_buffer_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = "\\brief Stream properties"]
#[doc = ""]
#[doc = " This structure is used to query or set properties of the decoded"]
#[doc = " stream."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_codec_stream_info {
    #[doc = "< Width (or 0 for unknown/default)"]
    pub w: ::std::os::raw::c_uint,
    #[doc = "< Height (or 0 for unknown/default)"]
    pub h: ::std::os::raw::c_uint,
    #[doc = "< Current frame is a keyframe"]
    pub is_kf: ::std::os::raw::c_uint,
    #[doc = "< Number of spatial layers"]
    pub number_spatial_layers: ::std::os::raw::c_uint,
    #[doc = "< Number of temporal layers"]
    pub number_temporal_layers: ::std::os::raw::c_uint,
    #[doc = "< Is Bitstream in Annex-B format"]
    pub is_annexb: ::std::os::raw::c_uint,
}
#[doc = "\\brief Stream properties"]
#[doc = ""]
#[doc = " This structure is used to query or set properties of the decoded"]
#[doc = " stream."]
pub type aom_codec_stream_info_t = aom_codec_stream_info;
#[doc = "\\brief Initialization Configurations"]
#[doc = ""]
#[doc = " This structure is used to pass init time configuration options to the"]
#[doc = " decoder."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_codec_dec_cfg {
    #[doc = "< Maximum number of threads to use, default 1"]
    pub threads: ::std::os::raw::c_uint,
    #[doc = "< Width"]
    pub w: ::std::os::raw::c_uint,
    #[doc = "< Height"]
    pub h: ::std::os::raw::c_uint,
    #[doc = "< Allow use of low-bitdepth coding path"]
    pub allow_lowbitdepth: ::std::os::raw::c_uint,
    #[doc = "< Options defined per config attributes"]
    pub cfg: cfg_options_t,
}
#[doc = "\\brief Initialization Configurations"]
#[doc = ""]
#[doc = " This structure is used to pass init time configuration options to the"]
#[doc = " decoder."]
pub type aom_codec_dec_cfg_t = aom_codec_dec_cfg;
extern "C" {
    #[doc = "\\brief Initialize a decoder instance"]
    #[doc = ""]
    #[doc = " Initializes a decoder context using the given interface. Applications"]
    #[doc = " should call the aom_codec_dec_init convenience macro instead of this"]
    #[doc = " function directly, to ensure that the ABI version number parameter"]
    #[doc = " is properly initialized."]
    #[doc = ""]
    #[doc = " If the library was configured with --disable-multithread, this call"]
    #[doc = " is not thread safe and should be guarded with a lock if being used"]
    #[doc = " in a multithreaded context."]
    #[doc = ""]
    #[doc = " \\param[in]    ctx     Pointer to this instance's context."]
    #[doc = " \\param[in]    iface   Pointer to the algorithm interface to use."]
    #[doc = " \\param[in]    cfg     Configuration to use, if known. May be NULL."]
    #[doc = " \\param[in]    flags   Bitfield of AOM_CODEC_USE_* flags"]
    #[doc = " \\param[in]    ver     ABI version number. Must be set to"]
    #[doc = "                       AOM_DECODER_ABI_VERSION"]
    #[doc = " \\retval #AOM_CODEC_OK"]
    #[doc = "     The decoder algorithm initialized."]
    #[doc = " \\retval #AOM_CODEC_MEM_ERROR"]
    #[doc = "     Memory allocation failed."]
    pub fn aom_codec_dec_init_ver(
        ctx: *mut aom_codec_ctx_t,
        iface: *mut aom_codec_iface_t,
        cfg: *const aom_codec_dec_cfg_t,
        flags: aom_codec_flags_t,
        ver: ::std::os::raw::c_int,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "\\brief Parse stream info from a buffer"]
    #[doc = ""]
    #[doc = " Performs high level parsing of the bitstream. Construction of a decoder"]
    #[doc = " context is not necessary. Can be used to determine if the bitstream is"]
    #[doc = " of the proper format, and to extract information from the stream."]
    #[doc = ""]
    #[doc = " \\param[in]      iface   Pointer to the algorithm interface"]
    #[doc = " \\param[in]      data    Pointer to a block of data to parse"]
    #[doc = " \\param[in]      data_sz Size of the data buffer"]
    #[doc = " \\param[in,out]  si      Pointer to stream info to update. The is_annexb"]
    #[doc = "                         member \\ref MUST be properly initialized. This"]
    #[doc = "                         function sets the rest of the members."]
    #[doc = ""]
    #[doc = " \\retval #AOM_CODEC_OK"]
    #[doc = "     Bitstream is parsable and stream information updated."]
    #[doc = " \\retval #AOM_CODEC_INVALID_PARAM"]
    #[doc = "     One of the arguments is invalid, for example a NULL pointer."]
    #[doc = " \\retval #AOM_CODEC_UNSUP_BITSTREAM"]
    #[doc = "     The decoder didn't recognize the coded data, or the"]
    #[doc = "     buffer was too short."]
    pub fn aom_codec_peek_stream_info(
        iface: *mut aom_codec_iface_t,
        data: *const u8,
        data_sz: usize,
        si: *mut aom_codec_stream_info_t,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "\\brief Return information about the current stream."]
    #[doc = ""]
    #[doc = " Returns information about the stream that has been parsed during decoding."]
    #[doc = ""]
    #[doc = " \\param[in]      ctx     Pointer to this instance's context"]
    #[doc = " \\param[in,out]  si      Pointer to stream info to update."]
    #[doc = ""]
    #[doc = " \\retval #AOM_CODEC_OK"]
    #[doc = "     Bitstream is parsable and stream information updated."]
    #[doc = " \\retval #AOM_CODEC_INVALID_PARAM"]
    #[doc = "     One of the arguments is invalid, for example a NULL pointer."]
    #[doc = " \\retval #AOM_CODEC_UNSUP_BITSTREAM"]
    #[doc = "     The decoder couldn't parse the submitted data."]
    pub fn aom_codec_get_stream_info(
        ctx: *mut aom_codec_ctx_t,
        si: *mut aom_codec_stream_info_t,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "\\brief Decode data"]
    #[doc = ""]
    #[doc = " Processes a buffer of coded data. If the processing results in a new"]
    #[doc = " decoded frame becoming available, PUT_SLICE and PUT_FRAME events may be"]
    #[doc = " generated, as appropriate. Encoded data \\ref MUST be passed in DTS (decode"]
    #[doc = " time stamp) order. Frames produced will always be in PTS (presentation"]
    #[doc = " time stamp) order."]
    #[doc = ""]
    #[doc = " \\param[in] ctx          Pointer to this instance's context"]
    #[doc = " \\param[in] data         Pointer to this block of new coded data. If"]
    #[doc = "                         NULL, a AOM_CODEC_CB_PUT_FRAME event is posted"]
    #[doc = "                         for the previously decoded frame."]
    #[doc = " \\param[in] data_sz      Size of the coded data, in bytes."]
    #[doc = " \\param[in] user_priv    Application specific data to associate with"]
    #[doc = "                         this frame."]
    #[doc = ""]
    #[doc = " \\return Returns #AOM_CODEC_OK if the coded data was processed completely"]
    #[doc = "         and future pictures can be decoded without error. Otherwise,"]
    #[doc = "         see the descriptions of the other error codes in ::aom_codec_err_t"]
    #[doc = "         for recoverability capabilities."]
    pub fn aom_codec_decode(
        ctx: *mut aom_codec_ctx_t,
        data: *const u8,
        data_sz: usize,
        user_priv: *mut ::std::os::raw::c_void,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "\\brief Decoded frames iterator"]
    #[doc = ""]
    #[doc = " Iterates over a list of the frames available for display. The iterator"]
    #[doc = " storage should be initialized to NULL to start the iteration. Iteration is"]
    #[doc = " complete when this function returns NULL."]
    #[doc = ""]
    #[doc = " The list of available frames becomes valid upon completion of the"]
    #[doc = " aom_codec_decode call, and remains valid until the next call to"]
    #[doc = " aom_codec_decode."]
    #[doc = ""]
    #[doc = " \\param[in]     ctx      Pointer to this instance's context"]
    #[doc = " \\param[in,out] iter     Iterator storage, initialized to NULL"]
    #[doc = ""]
    #[doc = " \\return Returns a pointer to an image, if one is ready for display. Frames"]
    #[doc = "         produced will always be in PTS (presentation time stamp) order."]
    pub fn aom_codec_get_frame(
        ctx: *mut aom_codec_ctx_t,
        iter: *mut aom_codec_iter_t,
    ) -> *mut aom_image_t;
}
#[doc = "\\brief put frame callback prototype"]
#[doc = ""]
#[doc = " This callback is invoked by the decoder to notify the application of"]
#[doc = " the availability of decoded image data."]
pub type aom_codec_put_frame_cb_fn_t = ::std::option::Option<
    unsafe extern "C" fn(user_priv: *mut ::std::os::raw::c_void, img: *const aom_image_t),
>;
extern "C" {
    #[doc = "\\brief Register for notification of frame completion."]
    #[doc = ""]
    #[doc = " Registers a given function to be called when a decoded frame is"]
    #[doc = " available."]
    #[doc = ""]
    #[doc = " \\param[in] ctx          Pointer to this instance's context"]
    #[doc = " \\param[in] cb           Pointer to the callback function"]
    #[doc = " \\param[in] user_priv    User's private data"]
    #[doc = ""]
    #[doc = " \\retval #AOM_CODEC_OK"]
    #[doc = "     Callback successfully registered."]
    #[doc = " \\retval #AOM_CODEC_ERROR"]
    #[doc = "     Decoder context not initialized, or algorithm not capable of"]
    #[doc = "     posting slice completion."]
    pub fn aom_codec_register_put_frame_cb(
        ctx: *mut aom_codec_ctx_t,
        cb: aom_codec_put_frame_cb_fn_t,
        user_priv: *mut ::std::os::raw::c_void,
    ) -> aom_codec_err_t;
}
#[doc = "\\brief put slice callback prototype"]
#[doc = ""]
#[doc = " This callback is invoked by the decoder to notify the application of"]
#[doc = " the availability of partially decoded image data. The"]
pub type aom_codec_put_slice_cb_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        user_priv: *mut ::std::os::raw::c_void,
        img: *const aom_image_t,
        valid: *const aom_image_rect_t,
        update: *const aom_image_rect_t,
    ),
>;
extern "C" {
    #[doc = "\\brief Register for notification of slice completion."]
    #[doc = ""]
    #[doc = " Registers a given function to be called when a decoded slice is"]
    #[doc = " available."]
    #[doc = ""]
    #[doc = " \\param[in] ctx          Pointer to this instance's context"]
    #[doc = " \\param[in] cb           Pointer to the callback function"]
    #[doc = " \\param[in] user_priv    User's private data"]
    #[doc = ""]
    #[doc = " \\retval #AOM_CODEC_OK"]
    #[doc = "     Callback successfully registered."]
    #[doc = " \\retval #AOM_CODEC_ERROR"]
    #[doc = "     Decoder context not initialized, or algorithm not capable of"]
    #[doc = "     posting slice completion."]
    pub fn aom_codec_register_put_slice_cb(
        ctx: *mut aom_codec_ctx_t,
        cb: aom_codec_put_slice_cb_fn_t,
        user_priv: *mut ::std::os::raw::c_void,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "\\brief Pass in external frame buffers for the decoder to use."]
    #[doc = ""]
    #[doc = " Registers functions to be called when libaom needs a frame buffer"]
    #[doc = " to decode the current frame and a function to be called when libaom does"]
    #[doc = " not internally reference the frame buffer. This set function must"]
    #[doc = " be called before the first call to decode or libaom will assume the"]
    #[doc = " default behavior of allocating frame buffers internally."]
    #[doc = ""]
    #[doc = " \\param[in] ctx          Pointer to this instance's context"]
    #[doc = " \\param[in] cb_get       Pointer to the get callback function"]
    #[doc = " \\param[in] cb_release   Pointer to the release callback function"]
    #[doc = " \\param[in] cb_priv      Callback's private data"]
    #[doc = ""]
    #[doc = " \\retval #AOM_CODEC_OK"]
    #[doc = "     External frame buffers will be used by libaom."]
    #[doc = " \\retval #AOM_CODEC_INVALID_PARAM"]
    #[doc = "     One or more of the callbacks were NULL."]
    #[doc = " \\retval #AOM_CODEC_ERROR"]
    #[doc = "     Decoder context not initialized, or algorithm not capable of"]
    #[doc = "     using external frame buffers."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " When decoding AV1, the application may be required to pass in at least"]
    #[doc = " #AOM_MAXIMUM_WORK_BUFFERS external frame"]
    #[doc = " buffers."]
    pub fn aom_codec_set_frame_buffer_functions(
        ctx: *mut aom_codec_ctx_t,
        cb_get: aom_get_frame_buffer_cb_fn_t,
        cb_release: aom_release_frame_buffer_cb_fn_t,
        cb_priv: *mut ::std::os::raw::c_void,
    ) -> aom_codec_err_t;
}
extern "C" {
    #[doc = "\\name Algorithm interface for AV1"]
    #[doc = ""]
    #[doc = " This interface provides the capability to encode raw AV1 streams."]
    #[doc = " @{"]
    pub static mut aom_codec_av1_cx_algo: aom_codec_iface_t;
}
extern "C" {
    pub fn aom_codec_av1_cx() -> *mut aom_codec_iface_t;
}
#[doc = "\\brief Codec control function to set which reference frame encoder can use."]
pub const AOME_USE_REFERENCE: aome_enc_control_id = 7;
#[doc = "\\brief Codec control function to pass an ROI map to encoder."]
pub const AOME_SET_ROI_MAP: aome_enc_control_id = 8;
#[doc = "\\brief Codec control function to pass an Active map to encoder."]
pub const AOME_SET_ACTIVEMAP: aome_enc_control_id = 9;
#[doc = "\\brief Codec control function to set encoder scaling mode."]
pub const AOME_SET_SCALEMODE: aome_enc_control_id = 11;
#[doc = "\\brief Codec control function to set encoder spatial layer id."]
pub const AOME_SET_SPATIAL_LAYER_ID: aome_enc_control_id = 12;
#[doc = "\\brief Codec control function to set encoder internal speed settings."]
#[doc = ""]
#[doc = " Changes in this value influences, among others, the encoder's selection"]
#[doc = " of motion estimation methods. Values greater than 0 will increase encoder"]
#[doc = " speed at the expense of quality."]
#[doc = ""]
#[doc = " \\note Valid range: 0..8"]
pub const AOME_SET_CPUUSED: aome_enc_control_id = 13;
#[doc = "\\brief Codec control function to enable automatic set and use alf frames."]
pub const AOME_SET_ENABLEAUTOALTREF: aome_enc_control_id = 14;
#[doc = "\\brief Codec control function to set sharpness."]
pub const AOME_SET_SHARPNESS: aome_enc_control_id = 16;
#[doc = "\\brief Codec control function to set the threshold for MBs treated static."]
pub const AOME_SET_STATIC_THRESHOLD: aome_enc_control_id = 17;
#[doc = "\\brief Codec control function to get last quantizer chosen by the encoder."]
#[doc = ""]
#[doc = " Return value uses internal quantizer scale defined by the codec."]
pub const AOME_GET_LAST_QUANTIZER: aome_enc_control_id = 19;
#[doc = "\\brief Codec control function to get last quantizer chosen by the encoder."]
#[doc = ""]
#[doc = " Return value uses the 0..63 scale as used by the rc_*_quantizer config"]
#[doc = " parameters."]
pub const AOME_GET_LAST_QUANTIZER_64: aome_enc_control_id = 20;
#[doc = "\\brief Codec control function to set the max no of frames to create arf."]
pub const AOME_SET_ARNR_MAXFRAMES: aome_enc_control_id = 21;
#[doc = "\\brief Codec control function to set the filter strength for the arf."]
pub const AOME_SET_ARNR_STRENGTH: aome_enc_control_id = 22;
#[doc = "\\brief Codec control function to set visual tuning."]
pub const AOME_SET_TUNING: aome_enc_control_id = 24;
#[doc = "\\brief Codec control function to set constrained quality level."]
#[doc = ""]
#[doc = " \\attention For this value to be used aom_codec_enc_cfg_t::rc_end_usage"]
#[doc = "            must be set to #AOM_CQ."]
#[doc = " \\note Valid range: 0..63"]
pub const AOME_SET_CQ_LEVEL: aome_enc_control_id = 25;
#[doc = "\\brief Codec control function to set Max data rate for Intra frames."]
#[doc = ""]
#[doc = " This value controls additional clamping on the maximum size of a"]
#[doc = " keyframe. It is expressed as a percentage of the average"]
#[doc = " per-frame bitrate, with the special (and default) value 0 meaning"]
#[doc = " unlimited, or no additional clamping beyond the codec's built-in"]
#[doc = " algorithm."]
#[doc = ""]
#[doc = " For example, to allocate no more than 4.5 frames worth of bitrate"]
#[doc = " to a keyframe, set this to 450."]
pub const AOME_SET_MAX_INTRA_BITRATE_PCT: aome_enc_control_id = 26;
#[doc = "\\brief Codec control function to set number of spatial layers."]
pub const AOME_SET_NUMBER_SPATIAL_LAYERS: aome_enc_control_id = 27;
#[doc = "\\brief Codec control function to set max data rate for Inter frames."]
#[doc = ""]
#[doc = " This value controls additional clamping on the maximum size of an"]
#[doc = " inter frame. It is expressed as a percentage of the average"]
#[doc = " per-frame bitrate, with the special (and default) value 0 meaning"]
#[doc = " unlimited, or no additional clamping beyond the codec's built-in"]
#[doc = " algorithm."]
#[doc = ""]
#[doc = " For example, to allow no more than 4.5 frames worth of bitrate"]
#[doc = " to an inter frame, set this to 450."]
pub const AV1E_SET_MAX_INTER_BITRATE_PCT: aome_enc_control_id = 28;
#[doc = "\\brief Boost percentage for Golden Frame in CBR mode."]
#[doc = ""]
#[doc = " This value controls the amount of boost given to Golden Frame in"]
#[doc = " CBR mode. It is expressed as a percentage of the average"]
#[doc = " per-frame bitrate, with the special (and default) value 0 meaning"]
#[doc = " the feature is off, i.e., no golden frame boost in CBR mode and"]
#[doc = " average bitrate target is used."]
#[doc = ""]
#[doc = " For example, to allow 100% more bits, i.e, 2X, in a golden frame"]
#[doc = " than average frame, set this to 100."]
pub const AV1E_SET_GF_CBR_BOOST_PCT: aome_enc_control_id = 29;
#[doc = "\\brief Codec control function to set lossless encoding mode."]
#[doc = ""]
#[doc = " AV1 can operate in lossless encoding mode, in which the bitstream"]
#[doc = " produced will be able to decode and reconstruct a perfect copy of"]
#[doc = " input source. This control function provides a mean to switch encoder"]
#[doc = " into lossless coding mode(1) or normal coding mode(0) that may be lossy."]
#[doc = "                          0 = lossy coding mode"]
#[doc = "                          1 = lossless coding mode"]
#[doc = ""]
#[doc = "  By default, encoder operates in normal coding mode (maybe lossy)."]
pub const AV1E_SET_LOSSLESS: aome_enc_control_id = 31;
#[doc = " control function to enable the row based multi-threading of encoder. A"]
#[doc = " value that is equal to 1 indicates that row based multi-threading is"]
#[doc = " enabled."]
pub const AV1E_SET_ROW_MT: aome_enc_control_id = 32;
#[doc = "\\brief Codec control function to set number of tile columns."]
#[doc = ""]
#[doc = " In encoding and decoding, AV1 allows an input image frame be partitioned"]
#[doc = " into separate vertical tile columns, which can be encoded or decoded"]
#[doc = " independently. This enables easy implementation of parallel encoding and"]
#[doc = " decoding. The parameter for this control describes the number of tile"]
#[doc = " columns (in log2 units), which has a valid range of [0, 6]:"]
#[doc = "             0 = 1 tile column"]
#[doc = "             1 = 2 tile columns"]
#[doc = "             2 = 4 tile columns"]
#[doc = "             ....."]
#[doc = "             n = 2**n tile columns"]
#[doc = ""]
#[doc = " By default, the value is 0, i.e. one single column tile for entire image."]
pub const AV1E_SET_TILE_COLUMNS: aome_enc_control_id = 33;
#[doc = "\\brief Codec control function to set number of tile rows."]
#[doc = ""]
#[doc = " In encoding and decoding, AV1 allows an input image frame be partitioned"]
#[doc = " into separate horizontal tile rows, which can be encoded or decoded"]
#[doc = " independently. The parameter for this control describes the number of tile"]
#[doc = " rows (in log2 units), which has a valid range of [0, 6]:"]
#[doc = "            0 = 1 tile row"]
#[doc = "            1 = 2 tile rows"]
#[doc = "            2 = 4 tile rows"]
#[doc = "            ....."]
#[doc = "            n = 2**n tile rows"]
#[doc = ""]
#[doc = " By default, the value is 0, i.e. one single row tile for entire image."]
pub const AV1E_SET_TILE_ROWS: aome_enc_control_id = 34;
#[doc = "\\brief Codec control function to enable RDO modulated by frame temporal"]
#[doc = " dependency."]
#[doc = ""]
#[doc = " By default, this feature is off."]
pub const AV1E_SET_ENABLE_TPL_MODEL: aome_enc_control_id = 35;
#[doc = "\\brief Codec control function to enable frame parallel decoding feature."]
#[doc = ""]
#[doc = " AV1 has a bitstream feature to reduce decoding dependency between frames"]
#[doc = " by turning off backward update of probability context used in encoding"]
#[doc = " and decoding. This allows staged parallel processing of more than one"]
#[doc = " video frames in the decoder. This control function provides a mean to"]
#[doc = " turn this feature on or off for bitstreams produced by encoder."]
#[doc = ""]
#[doc = " By default, this feature is off."]
pub const AV1E_SET_FRAME_PARALLEL_DECODING: aome_enc_control_id = 36;
#[doc = "\\brief Codec control function to enable error_resilient_mode"]
#[doc = ""]
#[doc = " AV1 has a bitstream feature to guarantee parseability of a frame"]
#[doc = " by turning on the error_resilient_decoding mode, even though the"]
#[doc = " reference buffers are unreliable or not received."]
#[doc = ""]
#[doc = " By default, this feature is off."]
pub const AV1E_SET_ERROR_RESILIENT_MODE: aome_enc_control_id = 37;
#[doc = "\\brief Codec control function to enable s_frame_mode"]
#[doc = ""]
#[doc = " AV1 has a bitstream feature to designate certain frames as S-frames,"]
#[doc = " from where we can switch to a different stream,"]
#[doc = " even though the reference buffers may not be exactly identical."]
#[doc = ""]
#[doc = " By default, this feature is off."]
pub const AV1E_SET_S_FRAME_MODE: aome_enc_control_id = 38;
#[doc = "\\brief Codec control function to set adaptive quantization mode."]
#[doc = ""]
#[doc = " AV1 has a segment based feature that allows encoder to adaptively change"]
#[doc = " quantization parameter for each segment within a frame to improve the"]
#[doc = " subjective quality. This control makes encoder operate in one of the"]
#[doc = " several AQ_modes supported."]
#[doc = ""]
#[doc = " By default, encoder operates with AQ_Mode 0(adaptive quantization off)."]
pub const AV1E_SET_AQ_MODE: aome_enc_control_id = 39;
#[doc = "\\brief Codec control function to enable/disable periodic Q boost."]
#[doc = ""]
#[doc = " One AV1 encoder speed feature is to enable quality boost by lowering"]
#[doc = " frame level Q periodically. This control function provides a mean to"]
#[doc = " turn on/off this feature."]
#[doc = "               0 = off"]
#[doc = "               1 = on"]
#[doc = ""]
#[doc = " By default, the encoder is allowed to use this feature for appropriate"]
#[doc = " encoding modes."]
pub const AV1E_SET_FRAME_PERIODIC_BOOST: aome_enc_control_id = 40;
#[doc = "\\brief Codec control function to set noise sensitivity."]
#[doc = ""]
#[doc = "  0: off, 1: On(YOnly)"]
pub const AV1E_SET_NOISE_SENSITIVITY: aome_enc_control_id = 41;
#[doc = "\\brief Codec control function to set content type."]
#[doc = " \\note Valid parameter range:"]
#[doc = "              AOM_CONTENT_DEFAULT = Regular video content (Default)"]
#[doc = "              AOM_CONTENT_SCREEN  = Screen capture content"]
pub const AV1E_SET_TUNE_CONTENT: aome_enc_control_id = 42;
#[doc = "\\brief Codec control function to set CDF update mode."]
#[doc = ""]
#[doc = "  0: no update          1: update on every frame"]
#[doc = "  2: selectively update"]
pub const AV1E_SET_CDF_UPDATE_MODE: aome_enc_control_id = 43;
#[doc = "\\brief Codec control function to set color space info."]
#[doc = " \\note Valid ranges: 0..23, default is \"Unspecified\"."]
#[doc = "                     0 = For future use"]
#[doc = "                     1 = BT.709"]
#[doc = "                     2 = Unspecified"]
#[doc = "                     3 = For future use"]
#[doc = "                     4 = BT.470 System M (historical)"]
#[doc = "                     5 = BT.470 System B, G (historical)"]
#[doc = "                     6 = BT.601"]
#[doc = "                     7 = SMPTE 240"]
#[doc = "                     8 = Generic film (color filters using illuminant C)"]
#[doc = "                     9 = BT.2020, BT.2100"]
#[doc = "                     10 = SMPTE 428 (CIE 1921 XYZ)"]
#[doc = "                     11 = SMPTE RP 431-2"]
#[doc = "                     12 = SMPTE EG 432-1"]
#[doc = "                     13 = For future use (values 13 - 21)"]
#[doc = "                     22 = EBU Tech. 3213-E"]
#[doc = "                     23 = For future use"]
#[doc = ""]
pub const AV1E_SET_COLOR_PRIMARIES: aome_enc_control_id = 44;
#[doc = "\\brief Codec control function to set transfer function info."]
#[doc = " \\note Valid ranges: 0..19, default is \"Unspecified\"."]
#[doc = "                     0 = For future use"]
#[doc = "                     1 = BT.709"]
#[doc = "                     2 = Unspecified"]
#[doc = "                     3 = For future use"]
#[doc = "                     4 = BT.470 System M (historical)"]
#[doc = "                     5 = BT.470 System B, G (historical)"]
#[doc = "                     6 = BT.601"]
#[doc = "                     7 = SMPTE 240 M"]
#[doc = "                     8 = Linear"]
#[doc = "                     9 = Logarithmic (100 : 1 range)"]
#[doc = "                     10 = Logarithmic (100 * Sqrt(10) : 1 range)"]
#[doc = "                     11 = IEC 61966-2-4"]
#[doc = "                     12 = BT.1361"]
#[doc = "                     13 = sRGB or sYCC"]
#[doc = "                     14 = BT.2020 10-bit systems"]
#[doc = "                     15 = BT.2020 12-bit systems"]
#[doc = "                     16 = SMPTE ST 2084, ITU BT.2100 PQ"]
#[doc = "                     17 = SMPTE ST 428"]
#[doc = "                     18 = BT.2100 HLG, ARIB STD-B67"]
#[doc = "                     19 = For future use"]
#[doc = ""]
pub const AV1E_SET_TRANSFER_CHARACTERISTICS: aome_enc_control_id = 45;
#[doc = "\\brief Codec control function to set transfer function info."]
#[doc = " \\note Valid ranges: 0..15, default is \"Unspecified\"."]
#[doc = "                     0 = Identity matrix"]
#[doc = "                     1 = BT.709"]
#[doc = "                     2 = Unspecified"]
#[doc = "                     3 = For future use"]
#[doc = "                     4 = US FCC 73.628"]
#[doc = "                     5 = BT.470 System B, G (historical)"]
#[doc = "                     6 = BT.601"]
#[doc = "                     7 = SMPTE 240 M"]
#[doc = "                     8 = YCgCo"]
#[doc = "                     9 = BT.2020 non-constant luminance, BT.2100 YCbCr"]
#[doc = "                     10 = BT.2020 constant luminance"]
#[doc = "                     11 = SMPTE ST 2085 YDzDx"]
#[doc = "                     12 = Chromaticity-derived non-constant luminance"]
#[doc = "                     13 = Chromaticity-derived constant luminance"]
#[doc = "                     14 = BT.2100 ICtCp"]
#[doc = "                     15 = For future use"]
#[doc = ""]
pub const AV1E_SET_MATRIX_COEFFICIENTS: aome_enc_control_id = 46;
#[doc = "\\brief Codec control function to set chroma 4:2:0 sample position info."]
#[doc = " \\note Valid ranges: 0..3, default is \"UNKNOWN\"."]
#[doc = "                     0 = UNKNOWN,"]
#[doc = "                     1 = VERTICAL"]
#[doc = "                     2 = COLOCATED"]
#[doc = "                     3 = RESERVED"]
pub const AV1E_SET_CHROMA_SAMPLE_POSITION: aome_enc_control_id = 47;
#[doc = "\\brief Codec control function to set minimum interval between GF/ARF frames"]
#[doc = ""]
#[doc = " By default the value is set as 4."]
pub const AV1E_SET_MIN_GF_INTERVAL: aome_enc_control_id = 48;
#[doc = "\\brief Codec control function to set minimum interval between GF/ARF frames"]
#[doc = ""]
#[doc = " By default the value is set as 16."]
pub const AV1E_SET_MAX_GF_INTERVAL: aome_enc_control_id = 49;
#[doc = "\\brief Codec control function to get an Active map back from the encoder."]
pub const AV1E_GET_ACTIVEMAP: aome_enc_control_id = 50;
#[doc = "\\brief Codec control function to set color range bit."]
#[doc = " \\note Valid ranges: 0..1, default is 0"]
#[doc = "                     0 = Limited range (16..235 or HBD equivalent)"]
#[doc = "                     1 = Full range (0..255 or HBD equivalent)"]
pub const AV1E_SET_COLOR_RANGE: aome_enc_control_id = 51;
#[doc = "\\brief Codec control function to set intended rendering image size."]
#[doc = ""]
#[doc = " By default, this is identical to the image size in pixels."]
pub const AV1E_SET_RENDER_SIZE: aome_enc_control_id = 52;
#[doc = "\\brief Control to set target sequence level index for a certain operating"]
#[doc = " point(OP)."]
#[doc = " Possible values are in the form of \"ABxy\"(pad leading zeros if less than"]
#[doc = " 4 digits)."]
#[doc = "   AB: OP index."]
#[doc = "   xy: Target level index for the OP. Can be values 0~23(corresponding to"]
#[doc = "   level 2.0 ~ 7.3) or 24(keep level stats only for level monitoring) or"]
#[doc = "   31(maximum level parameter, no level-based constraints)."]
#[doc = " E.g. \"0\" means target level index 0 for the 0th OP;"]
#[doc = "      \"111\" means target level index 11 for the 1st OP;"]
#[doc = "      \"1021\" means target level index 21 for the 10th OP."]
#[doc = " If the target level is not specified for an OP, the maximum level parameter"]
#[doc = " of 31 is used as default."]
pub const AV1E_SET_TARGET_SEQ_LEVEL_IDX: aome_enc_control_id = 53;
#[doc = "\\brief Codec control function to get sequence level index for each"]
#[doc = " operating point. There can be at most 32 operating points. The results will"]
#[doc = " be written into a provided integer array of sufficient size."]
pub const AV1E_GET_SEQ_LEVEL_IDX: aome_enc_control_id = 54;
#[doc = "\\brief Codec control function to set intended superblock size."]
#[doc = ""]
#[doc = " By default, the superblock size is determined separately for each"]
#[doc = " frame by the encoder."]
#[doc = ""]
#[doc = " Experiment: EXT_PARTITION"]
pub const AV1E_SET_SUPERBLOCK_SIZE: aome_enc_control_id = 55;
#[doc = "\\brief Codec control function to enable automatic set and use"]
#[doc = " bwd-pred frames."]
#[doc = ""]
pub const AOME_SET_ENABLEAUTOBWDREF: aome_enc_control_id = 56;
#[doc = "\\brief Codec control function to encode with CDEF."]
#[doc = ""]
#[doc = " CDEF is the constrained directional enhancement filter which is an"]
#[doc = " in-loop filter aiming to remove coding artifacts"]
#[doc = "                          0 = do not apply CDEF"]
#[doc = "                          1 = apply CDEF"]
#[doc = ""]
#[doc = "  By default, the encoder applies CDEF."]
#[doc = ""]
#[doc = " Experiment: AOM_CDEF"]
pub const AV1E_SET_ENABLE_CDEF: aome_enc_control_id = 57;
#[doc = "\\brief Codec control function to encode with Loop Restoration Filter."]
#[doc = ""]
#[doc = "                          0 = do not apply Restoration Filter"]
#[doc = "                          1 = apply Restoration Filter"]
#[doc = ""]
#[doc = "  By default, the encoder applies Restoration Filter."]
#[doc = ""]
pub const AV1E_SET_ENABLE_RESTORATION: aome_enc_control_id = 58;
#[doc = "\\brief Codec control function to predict with OBMC mode."]
#[doc = ""]
#[doc = "                          0 = do not allow OBMC mode"]
#[doc = "                          1 = allow OBMC mode"]
#[doc = ""]
#[doc = "  By default, the encoder allows OBMC prediction mode."]
#[doc = ""]
pub const AV1E_SET_ENABLE_OBMC: aome_enc_control_id = 59;
#[doc = "\\brief Codec control function to encode without trellis quantization."]
#[doc = ""]
#[doc = "                          0 = apply trellis quantization"]
#[doc = "                          1 = do not apply trellis quantization"]
#[doc = "                          2 = disable trellis quantization in rd search"]
#[doc = "                          3 = disable trellis quantization in estimate yrd"]
#[doc = ""]
#[doc = "  By default, the encoder applies optimization on quantized"]
#[doc = "  coefficients."]
#[doc = ""]
pub const AV1E_SET_DISABLE_TRELLIS_QUANT: aome_enc_control_id = 60;
#[doc = "\\brief Codec control function to encode with quantisation matrices."]
#[doc = ""]
#[doc = " AOM can operate with default quantisation matrices dependent on"]
#[doc = " quantisation level and block type."]
#[doc = "                          0 = do not use quantisation matrices"]
#[doc = "                          1 = use quantisation matrices"]
#[doc = ""]
#[doc = "  By default, the encoder operates without quantisation matrices."]
#[doc = ""]
#[doc = " Experiment: AOM_QM"]
pub const AV1E_SET_ENABLE_QM: aome_enc_control_id = 61;
#[doc = "\\brief Codec control function to set the min quant matrix flatness."]
#[doc = ""]
#[doc = " AOM can operate with different ranges of quantisation matrices."]
#[doc = " As quantisation levels increase, the matrices get flatter. This"]
#[doc = " control sets the minimum level of flatness from which the matrices"]
#[doc = " are determined."]
#[doc = ""]
#[doc = "  By default, the encoder sets this minimum at half the available"]
#[doc = "  range."]
#[doc = ""]
#[doc = " Experiment: AOM_QM"]
pub const AV1E_SET_QM_MIN: aome_enc_control_id = 62;
#[doc = "\\brief Codec control function to set the max quant matrix flatness."]
#[doc = ""]
#[doc = " AOM can operate with different ranges of quantisation matrices."]
#[doc = " As quantisation levels increase, the matrices get flatter. This"]
#[doc = " control sets the maximum level of flatness possible."]
#[doc = ""]
#[doc = " By default, the encoder sets this maximum at the top of the"]
#[doc = " available range."]
#[doc = ""]
#[doc = " Experiment: AOM_QM"]
pub const AV1E_SET_QM_MAX: aome_enc_control_id = 63;
#[doc = "\\brief Codec control function to set the min quant matrix flatness."]
#[doc = ""]
#[doc = " AOM can operate with different ranges of quantisation matrices."]
#[doc = " As quantisation levels increase, the matrices get flatter. This"]
#[doc = " control sets the flatness for luma (Y)."]
#[doc = ""]
#[doc = "  By default, the encoder sets this minimum at half the available"]
#[doc = "  range."]
#[doc = ""]
#[doc = " Experiment: AOM_QM"]
pub const AV1E_SET_QM_Y: aome_enc_control_id = 64;
#[doc = "\\brief Codec control function to set the min quant matrix flatness."]
#[doc = ""]
#[doc = " AOM can operate with different ranges of quantisation matrices."]
#[doc = " As quantisation levels increase, the matrices get flatter. This"]
#[doc = " control sets the flatness for chroma (U)."]
#[doc = ""]
#[doc = "  By default, the encoder sets this minimum at half the available"]
#[doc = "  range."]
#[doc = ""]
#[doc = " Experiment: AOM_QM"]
pub const AV1E_SET_QM_U: aome_enc_control_id = 65;
#[doc = "\\brief Codec control function to set the min quant matrix flatness."]
#[doc = ""]
#[doc = " AOM can operate with different ranges of quantisation matrices."]
#[doc = " As quantisation levels increase, the matrices get flatter. This"]
#[doc = " control sets the flatness for chrome (V)."]
#[doc = ""]
#[doc = "  By default, the encoder sets this minimum at half the available"]
#[doc = "  range."]
#[doc = ""]
#[doc = " Experiment: AOM_QM"]
pub const AV1E_SET_QM_V: aome_enc_control_id = 66;
#[doc = "\\brief Codec control function to encode with dist_8x8."]
#[doc = ""]
#[doc = "  The dist_8x8 is enabled automatically for model tuning parameters that"]
#[doc = "  require measuring distortion at the 8x8 level. This control also allows"]
#[doc = "  measuring distortion at the 8x8 level for other tuning options"]
#[doc = "  (e.g., PSNR), for testing purposes."]
#[doc = "                          0 = do not use dist_8x8"]
#[doc = "                          1 = use dist_8x8"]
#[doc = ""]
#[doc = "  By default, the encoder does not use dist_8x8"]
#[doc = ""]
#[doc = " Experiment: DIST_8X8"]
pub const AV1E_SET_ENABLE_DIST_8X8: aome_enc_control_id = 67;
#[doc = "\\brief Codec control function to set a maximum number of tile groups."]
#[doc = ""]
#[doc = " This will set the maximum number of tile groups. This will be"]
#[doc = " overridden if an MTU size is set. The default value is 1."]
#[doc = ""]
#[doc = " Experiment: TILE_GROUPS"]
pub const AV1E_SET_NUM_TG: aome_enc_control_id = 68;
#[doc = "\\brief Codec control function to set an MTU size for a tile group."]
#[doc = ""]
#[doc = " This will set the maximum number of bytes in a tile group. This can be"]
#[doc = " exceeded only if a single tile is larger than this amount."]
#[doc = ""]
#[doc = " By default, the value is 0, in which case a fixed number of tile groups"]
#[doc = " is used."]
#[doc = ""]
#[doc = " Experiment: TILE_GROUPS"]
pub const AV1E_SET_MTU: aome_enc_control_id = 69;
#[doc = "\\brief Codec control function to set the number of symbols in an ANS data"]
#[doc = " window."]
#[doc = ""]
#[doc = " The number of ANS symbols (both boolean and non-booleans alphabets) in an"]
#[doc = " ANS data window is set to 1 << value."]
#[doc = ""]
#[doc = " \\note Valid range: [8, 23]"]
#[doc = ""]
#[doc = " Experiment: ANS"]
pub const AV1E_SET_ANS_WINDOW_SIZE_LOG2: aome_enc_control_id = 70;
#[doc = "\\brief Codec control function to enable/disable rectangular partitions."]
#[doc = ""]
#[doc = " This will enable or disable usage of rectangular partitions. The default"]
#[doc = " value is 1."]
#[doc = ""]
pub const AV1E_SET_ENABLE_RECT_PARTITIONS: aome_enc_control_id = 71;
#[doc = "\\brief Codec control function to enable/disable AB partitions."]
#[doc = ""]
#[doc = " This will enable or disable usage of AB partitions. The default"]
#[doc = " value is 1."]
#[doc = ""]
pub const AV1E_SET_ENABLE_AB_PARTITIONS: aome_enc_control_id = 72;
#[doc = "\\brief Codec control function to enable/disable 1:4 and 4:1 partitions."]
#[doc = ""]
#[doc = " This will enable or disable usage of 1:4 and 4:1 partitions. The default"]
#[doc = " value is 1."]
#[doc = ""]
pub const AV1E_SET_ENABLE_1TO4_PARTITIONS: aome_enc_control_id = 73;
#[doc = "\\brief Codec control function to set min partition size."]
#[doc = ""]
#[doc = " This will set min partition size. The default value is 4 for 4x4."]
#[doc = " valid values are [4, 8, 16, 32, 64, 128]"]
#[doc = " min_partition_size is applied to both width and height of the partition."]
#[doc = " i.e, both width and height of a partition can not be smaller than"]
#[doc = " the min_partition_size, except the partition at the picture boundary."]
#[doc = ""]
pub const AV1E_SET_MIN_PARTITION_SIZE: aome_enc_control_id = 74;
#[doc = "\\brief Codec control function to set max partition size."]
#[doc = ""]
#[doc = " This will set max partition size. The default value is 128 for 128x128."]
#[doc = " valid values are [4, 8, 16, 32, 64, 128]"]
#[doc = " max_partition_size is applied to both width and height of the partition."]
#[doc = " i.e, both width and height of a partition can not be larger than"]
#[doc = " the max_partition_size."]
pub const AV1E_SET_MAX_PARTITION_SIZE: aome_enc_control_id = 75;
#[doc = "\\brief Codec control function to turn on / off intra edge filter"]
#[doc = " at sequence level."]
#[doc = ""]
#[doc = " This will enable or disable usage of intra-edge filtering. The default"]
#[doc = " value is 1."]
#[doc = ""]
pub const AV1E_SET_ENABLE_INTRA_EDGE_FILTER: aome_enc_control_id = 76;
#[doc = "\\brief Codec control function to turn on / off frame order hint for a"]
#[doc = " few tools:"]
#[doc = ""]
#[doc = " joint compound mode"]
#[doc = " motion field motion vector"]
#[doc = " ref frame sign bias"]
#[doc = ""]
#[doc = " The default value is 1."]
#[doc = ""]
pub const AV1E_SET_ENABLE_ORDER_HINT: aome_enc_control_id = 77;
#[doc = "\\brief Codec control function to turn on / off 64-length transforms."]
#[doc = ""]
#[doc = " This will enable or disable usage of length 64 transforms in any"]
#[doc = " direction. The default value is 1."]
#[doc = ""]
pub const AV1E_SET_ENABLE_TX64: aome_enc_control_id = 78;
#[doc = "\\brief Codec control function to turn on / off flip and identity"]
#[doc = " transforms."]
#[doc = ""]
#[doc = " This will enable or disable usage of flip and identity transform"]
#[doc = " types in any direction. The default value is 1. Including:"]
#[doc = " FLIPADST_DCT, DCT_FLIPADST, FLIPADST_FLIPADST, ADST_FLIPADST,"]
#[doc = " FLIPADST_ADST, IDTX, V_DCT, H_DCT, V_ADST, H_ADST, V_FLIPADST,"]
#[doc = " H_FLIPADST"]
pub const AV1E_SET_ENABLE_FLIP_IDTX: aome_enc_control_id = 79;
#[doc = "\\brief Codec control function to set transform block size search method."]
#[doc = ""]
#[doc = " This will set the transform block size search method."]
#[doc = " 0: use Full RD search, 1: use Fast RD search, 2: always use largest"]
#[doc = " allowed transform block size based on partition size."]
pub const AV1E_SET_TX_SIZE_SEARCH_METHOD: aome_enc_control_id = 80;
#[doc = "\\brief Codec control function to turn on / off dist-wtd compound mode"]
#[doc = " at sequence level."]
#[doc = ""]
#[doc = " This will enable or disable distance-weighted compound mode. The default"]
#[doc = " value is 1. If AV1E_SET_ENABLE_ORDER_HINT is 0, then this flag is forced"]
#[doc = " to 0."]
#[doc = ""]
pub const AV1E_SET_ENABLE_DIST_WTD_COMP: aome_enc_control_id = 81;
#[doc = "\\brief Codec control function to turn on / off ref frame mvs (mfmv) usage"]
#[doc = " at sequence level."]
#[doc = ""]
#[doc = " This will enable or disable usage of MFMV. The default value is 1."]
#[doc = " If AV1E_SET_ENABLE_ORDER_HINT is 0, then this flag is forced to 0."]
#[doc = ""]
pub const AV1E_SET_ENABLE_REF_FRAME_MVS: aome_enc_control_id = 82;
#[doc = "\\brief Codec control function to set temporal mv prediction"]
#[doc = " enabling/disabling at frame level."]
#[doc = ""]
#[doc = " This will enable or disable temporal mv predicton. The default value is 1."]
#[doc = " If AV1E_SET_ENABLE_REF_FRAME_MVS is 0, then this flag is forced to 0."]
#[doc = ""]
pub const AV1E_SET_ALLOW_REF_FRAME_MVS: aome_enc_control_id = 83;
#[doc = "\\brief Codec control function to turn on / off dual filter usage"]
#[doc = " for a sequence."]
#[doc = ""]
#[doc = " This will enable or disable use of dual interpolation filter."]
#[doc = " The default value is 1."]
#[doc = ""]
pub const AV1E_SET_ENABLE_DUAL_FILTER: aome_enc_control_id = 84;
#[doc = "\\brief Codec control function to turn on / off delta quantization in chroma"]
#[doc = " planes usage for a sequence."]
#[doc = ""]
#[doc = " This will enable or disable use of chroma deltaq."]
#[doc = " The default value is 0."]
#[doc = ""]
pub const AV1E_SET_ENABLE_CHROMA_DELTAQ: aome_enc_control_id = 85;
#[doc = "\\brief Codec control function to turn on / off masked compound usage"]
#[doc = " for a sequence."]
#[doc = ""]
#[doc = " This will enable or disable usage of wedge and diff-wtd compound"]
#[doc = " modes. The default value is 1."]
#[doc = ""]
pub const AV1E_SET_ENABLE_MASKED_COMP: aome_enc_control_id = 86;
#[doc = "\\brief Codec control function to turn on / off one sided compound usage"]
#[doc = " for a sequence."]
#[doc = ""]
#[doc = " This will enable or disable usage of one sided compound"]
#[doc = " modes. The default value is 1."]
#[doc = ""]
pub const AV1E_SET_ENABLE_ONESIDED_COMP: aome_enc_control_id = 87;
#[doc = "\\brief Codec control function to turn on / off interintra compound"]
#[doc = " for a sequence."]
#[doc = ""]
#[doc = " This will enable or disable usage of inter-intra compound modes."]
#[doc = " The default value is 1."]
#[doc = ""]
pub const AV1E_SET_ENABLE_INTERINTRA_COMP: aome_enc_control_id = 88;
#[doc = "\\brief Codec control function to turn on / off smooth inter-intra"]
#[doc = " mode for a sequence."]
#[doc = ""]
#[doc = " This will enable or disable usage of smooth inter-intra mode."]
#[doc = " The default value is 1."]
#[doc = ""]
pub const AV1E_SET_ENABLE_SMOOTH_INTERINTRA: aome_enc_control_id = 89;
#[doc = "\\brief Codec control function to turn on / off difference weighted"]
#[doc = " compound."]
#[doc = ""]
#[doc = " This will enable or disable usage of difference weighted compound."]
#[doc = " The default value is 1."]
#[doc = ""]
pub const AV1E_SET_ENABLE_DIFF_WTD_COMP: aome_enc_control_id = 90;
#[doc = "\\brief Codec control function to turn on / off interinter wedge"]
#[doc = " compound."]
#[doc = ""]
#[doc = " This will enable or disable usage of interinter wedge compound."]
#[doc = " The default value is 1."]
#[doc = ""]
pub const AV1E_SET_ENABLE_INTERINTER_WEDGE: aome_enc_control_id = 91;
#[doc = "\\brief Codec control function to turn on / off interintra wedge"]
#[doc = " compound."]
#[doc = ""]
#[doc = " This will enable or disable usage of interintra wedge compound."]
#[doc = " The default value is 1."]
#[doc = ""]
pub const AV1E_SET_ENABLE_INTERINTRA_WEDGE: aome_enc_control_id = 92;
#[doc = "\\brief Codec control function to turn on / off global motion usage"]
#[doc = " for a sequence."]
#[doc = ""]
#[doc = " This will enable or disable usage of global motion. The default value is 1."]
#[doc = ""]
pub const AV1E_SET_ENABLE_GLOBAL_MOTION: aome_enc_control_id = 93;
#[doc = "\\brief Codec control function to turn on / off warped motion usage"]
#[doc = " at sequence level."]
#[doc = ""]
#[doc = " This will enable or disable usage of warped motion. The default value is 1."]
#[doc = ""]
pub const AV1E_SET_ENABLE_WARPED_MOTION: aome_enc_control_id = 94;
#[doc = "\\brief Codec control function to turn on / off warped motion usage"]
#[doc = " at frame level."]
#[doc = ""]
#[doc = " This will enable or disable usage of warped motion. The default value is 1."]
#[doc = " If AV1E_SET_ENABLE_WARPED_MOTION is 0, then this flag is forced to 0."]
#[doc = ""]
pub const AV1E_SET_ALLOW_WARPED_MOTION: aome_enc_control_id = 95;
#[doc = "\\brief Codec control function to turn on / off filter intra usage at"]
#[doc = " sequence level."]
#[doc = ""]
#[doc = " This will enable or disable usage of filter intra. The default value is 1."]
#[doc = " If AV1E_SET_ENABLE_FILTER_INTRA is 0, then this flag is forced to 0."]
#[doc = ""]
pub const AV1E_SET_ENABLE_FILTER_INTRA: aome_enc_control_id = 96;
#[doc = "\\brief Codec control function to turn on / off smooth intra modes usage."]
#[doc = ""]
#[doc = " This will enable or disable usage of smooth, smooth_h and smooth_v intra"]
#[doc = " modes. The default value is 1."]
#[doc = ""]
pub const AV1E_SET_ENABLE_SMOOTH_INTRA: aome_enc_control_id = 97;
#[doc = "\\brief Codec control function to turn on / off Paeth intra mode usage."]
#[doc = ""]
#[doc = " This will enable or disable usage of Paeth intra mode. The default value"]
#[doc = " is 1."]
#[doc = ""]
pub const AV1E_SET_ENABLE_PAETH_INTRA: aome_enc_control_id = 98;
#[doc = "\\brief Codec control function to turn on / off CFL uv intra mode usage."]
#[doc = ""]
#[doc = " This will enable or disable usage of chroma-from-luma intra mode. The"]
#[doc = " default value is 1."]
#[doc = ""]
pub const AV1E_SET_ENABLE_CFL_INTRA: aome_enc_control_id = 99;
#[doc = "\\brief Codec control function to turn on / off frame superresolution."]
#[doc = ""]
#[doc = " This will enable or disable frame superresolution. The default value is 1"]
#[doc = " If AV1E_SET_ENABLE_SUPERRES is 0, then this flag is forced to 0."]
pub const AV1E_SET_ENABLE_SUPERRES: aome_enc_control_id = 100;
#[doc = "\\brief Codec control function to turn on/off palette mode"]
pub const AV1E_SET_ENABLE_PALETTE: aome_enc_control_id = 101;
#[doc = "\\brief Codec control function to turn on/off intra block copy mode"]
pub const AV1E_SET_ENABLE_INTRABC: aome_enc_control_id = 102;
#[doc = "\\brief Codec control function to turn on/off intra angle delta"]
pub const AV1E_SET_ENABLE_ANGLE_DELTA: aome_enc_control_id = 103;
#[doc = "\\brief Codec control function to set the delta q mode"]
#[doc = ""]
#[doc = " AV1 supports a delta q mode feature, that allows modulating q per"]
#[doc = " superblock. This control makes encoder operate in one of several"]
#[doc = " DELTA_Q_modes supported:"]
#[doc = " 0: Not Supported"]
#[doc = " 1: Use modulation to maximize objective quality"]
#[doc = " 2: Use modulation to maximize perceptual quality"]
#[doc = ""]
#[doc = " By default, encoder operates with DELTAQ_Mode 0(deltaq signaling off)."]
pub const AV1E_SET_DELTAQ_MODE: aome_enc_control_id = 104;
#[doc = "\\brief Codec control function to turn on/off loopfilter modulation"]
#[doc = " when delta q modulation is enabled. Note AV1 only supports loopfilter"]
#[doc = " modulation when delta q modulation is enabled as well."]
pub const AV1E_SET_DELTALF_MODE: aome_enc_control_id = 105;
#[doc = "\\brief Codec control function to set the single tile decoding mode to 0 or"]
#[doc = " 1."]
#[doc = ""]
#[doc = " 0 means that the single tile decoding is off, and 1 means that the single"]
#[doc = " tile decoding is on."]
#[doc = ""]
#[doc = " Experiment: EXT_TILE"]
pub const AV1E_SET_SINGLE_TILE_DECODING: aome_enc_control_id = 106;
#[doc = "\\brief Codec control function to enable the extreme motion vector unit test"]
#[doc = " in AV1. Please note that this is only used in motion vector unit test."]
#[doc = ""]
#[doc = " 0 : off, 1 : MAX_EXTREME_MV, 2 : MIN_EXTREME_MV"]
pub const AV1E_ENABLE_MOTION_VECTOR_UNIT_TEST: aome_enc_control_id = 107;
#[doc = "\\brief Codec control function to signal picture timing info in the"]
#[doc = " bitstream. \\note Valid ranges: 0..1, default is \"UNKNOWN\". 0 = UNKNOWN, 1 ="]
#[doc = " EQUAL"]
pub const AV1E_SET_TIMING_INFO_TYPE: aome_enc_control_id = 108;
#[doc = "\\brief Codec control function to add film grain parameters (one of several"]
#[doc = " preset types) info in the bitstream."]
#[doc = " \\note Valid ranges: 0..11, default is \"0\". 0 = UNKNOWN,"]
#[doc = " 1..16 = different test vectors for grain"]
pub const AV1E_SET_FILM_GRAIN_TEST_VECTOR: aome_enc_control_id = 109;
#[doc = "\\brief Codec control function to set the path to the film grain parameters"]
pub const AV1E_SET_FILM_GRAIN_TABLE: aome_enc_control_id = 110;
#[doc = "\\brief Sets the noise level"]
pub const AV1E_SET_DENOISE_NOISE_LEVEL: aome_enc_control_id = 111;
#[doc = "\\brief Sets the denoisers block size"]
pub const AV1E_SET_DENOISE_BLOCK_SIZE: aome_enc_control_id = 112;
#[doc = "\\brief Sets the chroma subsampling x value"]
pub const AV1E_SET_CHROMA_SUBSAMPLING_X: aome_enc_control_id = 113;
#[doc = "\\brief Sets the chroma subsampling y value"]
pub const AV1E_SET_CHROMA_SUBSAMPLING_Y: aome_enc_control_id = 114;
#[doc = "\\brief Control to use a reduced tx type set"]
pub const AV1E_SET_REDUCED_TX_TYPE_SET: aome_enc_control_id = 115;
#[doc = "\\brief Control to use dct only for intra modes"]
pub const AV1E_SET_INTRA_DCT_ONLY: aome_enc_control_id = 116;
#[doc = "\\brief Control to use dct only for inter modes"]
pub const AV1E_SET_INTER_DCT_ONLY: aome_enc_control_id = 117;
#[doc = "\\brief Control to use default tx type only for intra modes"]
pub const AV1E_SET_INTRA_DEFAULT_TX_ONLY: aome_enc_control_id = 118;
#[doc = "\\brief Control to use adaptive quantize_b"]
pub const AV1E_SET_QUANT_B_ADAPT: aome_enc_control_id = 119;
#[doc = "\\brief Control to select maximum height for the GF group pyramid structure"]
#[doc = " (valid values: 0 - 4)"]
pub const AV1E_SET_GF_MAX_PYRAMID_HEIGHT: aome_enc_control_id = 120;
#[doc = "\\brief Control to select maximum reference frames allowed per frame"]
#[doc = " (valid values: 3 - 7)"]
pub const AV1E_SET_MAX_REFERENCE_FRAMES: aome_enc_control_id = 121;
#[doc = "\\brief Control to use reduced set of single and compound references."]
pub const AV1E_SET_REDUCED_REFERENCE_SET: aome_enc_control_id = 122;
#[doc = "\\brief Control to set frequency of the cost updates for coefficients"]
#[doc = " Possible values are:"]
#[doc = " 0: Update at SB level (default)"]
#[doc = " 1: Update at SB row level in tile"]
#[doc = " 2: Update at tile level"]
pub const AV1E_SET_COEFF_COST_UPD_FREQ: aome_enc_control_id = 123;
#[doc = "\\brief Control to set frequency of the cost updates for mode"]
#[doc = " Possible values are:"]
#[doc = " 0: Update at SB level (default)"]
#[doc = " 1: Update at SB row level in tile"]
#[doc = " 2: Update at tile level"]
pub const AV1E_SET_MODE_COST_UPD_FREQ: aome_enc_control_id = 124;
#[doc = "\\brief Control to set bit mask that specifies which tier each of the 32"]
#[doc = " possible operating points conforms to."]
#[doc = " Bit value 0: Main Tier; 1: High Tier."]
pub const AV1E_SET_TIER_MASK: aome_enc_control_id = 125;
#[doc = "\\brief Control to set minimum compression ratio."]
#[doc = " Take integer values. If non-zero, encoder will try to keep the compression"]
#[doc = " ratio of each frame to be higher than the given value divided by 100."]
#[doc = " E.g. 850 means minimum compression ratio of 8.5."]
pub const AV1E_SET_MIN_CR: aome_enc_control_id = 126;
#[doc = "\\brief Codec control function to set the layer id."]
pub const AV1E_SET_SVC_LAYER_ID: aome_enc_control_id = 150;
#[doc = "\\brief Codec control function to set SVC paramaeters."]
pub const AV1E_SET_SVC_PARAMS: aome_enc_control_id = 151;
#[doc = "\\brief Codec control function to set SVC reference frame map."]
pub const AV1E_SET_SVC_REF_IDX: aome_enc_control_id = 152;
#[doc = "\\brief AVx encoder control functions"]
#[doc = ""]
#[doc = " This set of macros define the control functions available for AVx"]
#[doc = " encoder interface."]
#[doc = ""]
#[doc = " \\sa #aom_codec_control"]
pub type aome_enc_control_id = ::std::os::raw::c_uint;
pub const AOME_NORMAL: aom_scaling_mode_1d = 0;
pub const AOME_FOURFIVE: aom_scaling_mode_1d = 1;
pub const AOME_THREEFIVE: aom_scaling_mode_1d = 2;
pub const AOME_ONETWO: aom_scaling_mode_1d = 3;
#[doc = "\\brief aom 1-D scaling mode"]
#[doc = ""]
#[doc = " This set of constants define 1-D aom scaling modes"]
pub type aom_scaling_mode_1d = ::std::os::raw::c_uint;
#[doc = "\\brief aom 1-D scaling mode"]
#[doc = ""]
#[doc = " This set of constants define 1-D aom scaling modes"]
pub use self::aom_scaling_mode_1d as AOM_SCALING_MODE;
#[doc = "\\brief  aom region of interest map"]
#[doc = ""]
#[doc = " These defines the data structures for the region of interest map"]
#[doc = ""]
#[doc = " TODO(yaowu): create a unit test for ROI map related APIs"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_roi_map {
    #[doc = " An id between 0 and 7 for each 8x8 region within a frame."]
    pub roi_map: *mut ::std::os::raw::c_uchar,
    #[doc = "< Number of rows."]
    pub rows: ::std::os::raw::c_uint,
    #[doc = "< Number of columns."]
    pub cols: ::std::os::raw::c_uint,
    #[doc = "< Quantizer deltas."]
    pub delta_q: [::std::os::raw::c_int; 8usize],
    #[doc = "< Loop filter deltas."]
    pub delta_lf: [::std::os::raw::c_int; 8usize],
    #[doc = " Static breakout threshold for each segment."]
    pub static_threshold: [::std::os::raw::c_uint; 8usize],
}
#[doc = "\\brief  aom region of interest map"]
#[doc = ""]
#[doc = " These defines the data structures for the region of interest map"]
#[doc = ""]
#[doc = " TODO(yaowu): create a unit test for ROI map related APIs"]
#[doc = ""]
pub type aom_roi_map_t = aom_roi_map;
#[doc = "\\brief  aom active region map"]
#[doc = ""]
#[doc = " These defines the data structures for active region map"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_active_map {
    #[doc = "\\brief specify an on (1) or off (0) each 16x16 region within a frame"]
    pub active_map: *mut ::std::os::raw::c_uchar,
    #[doc = "< number of rows"]
    pub rows: ::std::os::raw::c_uint,
    #[doc = "< number of cols"]
    pub cols: ::std::os::raw::c_uint,
}
#[doc = "\\brief  aom active region map"]
#[doc = ""]
#[doc = " These defines the data structures for active region map"]
#[doc = ""]
pub type aom_active_map_t = aom_active_map;
#[doc = "\\brief  aom image scaling mode"]
#[doc = ""]
#[doc = " This defines the data structure for image scaling mode"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_scaling_mode {
    #[doc = "< horizontal scaling mode"]
    pub h_scaling_mode: AOM_SCALING_MODE,
    #[doc = "< vertical scaling mode"]
    pub v_scaling_mode: AOM_SCALING_MODE,
}
#[doc = "\\brief  aom image scaling mode"]
#[doc = ""]
#[doc = " This defines the data structure for image scaling mode"]
#[doc = ""]
pub type aom_scaling_mode_t = aom_scaling_mode;
pub const AOM_CONTENT_DEFAULT: aom_tune_content = 0;
pub const AOM_CONTENT_SCREEN: aom_tune_content = 1;
pub const AOM_CONTENT_INVALID: aom_tune_content = 2;
#[doc = "brief AV1 encoder content type"]
pub type aom_tune_content = ::std::os::raw::c_uint;
pub const AOM_TIMING_UNSPECIFIED: aom_timing_info_type_t = 0;
pub const AOM_TIMING_EQUAL: aom_timing_info_type_t = 1;
pub const AOM_TIMING_DEC_MODEL: aom_timing_info_type_t = 2;
#[doc = "brief AV1 encoder timing info type signaling"]
pub type aom_timing_info_type_t = ::std::os::raw::c_uint;
pub const AOM_TUNE_PSNR: aom_tune_metric = 0;
pub const AOM_TUNE_SSIM: aom_tune_metric = 1;
pub const AOM_TUNE_CDEF_DIST: aom_tune_metric = 2;
pub const AOM_TUNE_DAALA_DIST: aom_tune_metric = 3;
#[doc = "\\brief Model tuning parameters"]
#[doc = ""]
#[doc = " Changes the encoder to tune for certain types of input material."]
#[doc = ""]
pub type aom_tune_metric = ::std::os::raw::c_uint;
#[doc = "brief Struct for spatial and temporal layer ID"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_svc_layer_id {
    #[doc = "< Spatial layer ID"]
    pub spatial_layer_id: ::std::os::raw::c_int,
    #[doc = "< Temporal layer ID"]
    pub temporal_layer_id: ::std::os::raw::c_int,
}
#[doc = "brief Struct for spatial and temporal layer ID"]
pub type aom_svc_layer_id_t = aom_svc_layer_id;
#[doc = "brief Parameter type for SVC"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_svc_params {
    #[doc = "< Number of spatial layers"]
    pub number_spatial_layers: ::std::os::raw::c_int,
    #[doc = "< Number of temporal layers"]
    pub number_temporal_layers: ::std::os::raw::c_int,
    #[doc = "< Max Q for each layer"]
    pub max_quantizers: [::std::os::raw::c_int; 32usize],
    #[doc = "< Min Q for each layer"]
    pub min_quantizers: [::std::os::raw::c_int; 32usize],
    #[doc = "< Scaling factor-numerator"]
    pub scaling_factor_num: [::std::os::raw::c_int; 4usize],
    #[doc = "< Scaling factor-denominator"]
    pub scaling_factor_den: [::std::os::raw::c_int; 4usize],
    #[doc = " Target bitrate for each layer"]
    pub layer_target_bitrate: [::std::os::raw::c_int; 32usize],
    #[doc = " Frame rate factor for each temporal layer"]
    pub framerate_factor: [::std::os::raw::c_int; 8usize],
}
#[doc = "brief Parameter type for SVC"]
pub type aom_svc_params_t = aom_svc_params;
#[doc = "brief Parameter type for SVC"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_svc_ref_idx {
    #[doc = "< Reference buffer slot"]
    pub ref_idx: [::std::os::raw::c_int; 8usize],
}
#[doc = "brief Parameter type for SVC"]
pub type aom_svc_ref_idx_t = aom_svc_ref_idx;
extern "C" {
    #[doc = "\\name Algorithm interface for AV1"]
    #[doc = ""]
    #[doc = " This interface provides the capability to decode AV1 streams."]
    #[doc = " @{"]
    pub static mut aom_codec_av1_dx_algo: aom_codec_iface_t;
}
extern "C" {
    pub fn aom_codec_av1_dx() -> *mut aom_codec_iface_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Accounting {
    _unused: [u8; 0],
}
#[doc = " Callback that inspects decoder frame data."]
pub type aom_inspect_cb = ::std::option::Option<
    unsafe extern "C" fn(decoder: *mut ::std::os::raw::c_void, ctx: *mut ::std::os::raw::c_void),
>;
#[doc = "\\brief Structure to hold inspection callback and context."]
#[doc = ""]
#[doc = " Defines a structure to hold the inspection callback function and calling"]
#[doc = " context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_inspect_init {
    #[doc = " Inspection callback."]
    pub inspect_cb: aom_inspect_cb,
    #[doc = " Inspection context."]
    pub inspect_ctx: *mut ::std::os::raw::c_void,
}
#[doc = "\\brief Structure to hold a tile's start address and size in the bitstream."]
#[doc = ""]
#[doc = " Defines a structure to hold a tile's start address and size in the bitstream."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct aom_tile_data {
    #[doc = " Tile data size."]
    pub coded_tile_data_size: usize,
    #[doc = " Tile's start address."]
    pub coded_tile_data: *const ::std::os::raw::c_void,
    #[doc = " Extra size information."]
    pub extra_size: usize,
}
#[doc = "\\brief Structure to hold the external reference frame pointer."]
#[doc = ""]
#[doc = " Define a structure to hold the external reference frame pointer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct av1_ext_ref_frame {
    #[doc = " Start pointer of external references."]
    pub img: *mut aom_image_t,
    #[doc = " Number of available external references."]
    pub num: ::std::os::raw::c_int,
}
#[doc = "\\brief Structure to hold the external reference frame pointer."]
#[doc = ""]
#[doc = " Define a structure to hold the external reference frame pointer."]
pub type av1_ext_ref_frame_t = av1_ext_ref_frame;
#[doc = " control function to get info on which reference frames were updated"]
#[doc = "  by the last decode"]
pub const AOMD_GET_LAST_REF_UPDATES: aom_dec_control_id = 256;
#[doc = " check if the indicated frame is corrupted"]
pub const AOMD_GET_FRAME_CORRUPTED: aom_dec_control_id = 257;
#[doc = " control function to get info on which reference frames were used"]
#[doc = "  by the last decode"]
pub const AOMD_GET_LAST_REF_USED: aom_dec_control_id = 258;
#[doc = " control function to get the dimensions that the current frame is decoded"]
#[doc = " at. This may be different to the intended display size for the frame as"]
#[doc = " specified in the wrapper or frame header (see AV1D_GET_DISPLAY_SIZE)."]
pub const AV1D_GET_FRAME_SIZE: aom_dec_control_id = 259;
#[doc = " control function to get the current frame's intended display dimensions"]
#[doc = " (as specified in the wrapper or frame header). This may be different to"]
#[doc = " the decoded dimensions of this frame (see AV1D_GET_FRAME_SIZE)."]
pub const AV1D_GET_DISPLAY_SIZE: aom_dec_control_id = 260;
#[doc = " control function to get the bit depth of the stream."]
pub const AV1D_GET_BIT_DEPTH: aom_dec_control_id = 261;
#[doc = " control function to get the image format of the stream."]
pub const AV1D_GET_IMG_FORMAT: aom_dec_control_id = 262;
#[doc = " control function to get the size of the tile."]
pub const AV1D_GET_TILE_SIZE: aom_dec_control_id = 263;
#[doc = " control function to get the tile count in a tile list."]
pub const AV1D_GET_TILE_COUNT: aom_dec_control_id = 264;
#[doc = " control function to set the byte alignment of the planes in the reference"]
#[doc = " buffers. Valid values are power of 2, from 32 to 1024. A value of 0 sets"]
#[doc = " legacy alignment. I.e. Y plane is aligned to 32 bytes, U plane directly"]
#[doc = " follows Y plane, and V plane directly follows U plane. Default value is 0."]
pub const AV1_SET_BYTE_ALIGNMENT: aom_dec_control_id = 265;
#[doc = " control function to invert the decoding order to from right to left. The"]
#[doc = " function is used in a test to confirm the decoding independence of tile"]
#[doc = " columns. The function may be used in application where this order"]
#[doc = " of decoding is desired."]
#[doc = ""]
#[doc = " TODO(yaowu): Rework the unit test that uses this control, and in a future"]
#[doc = "              release, this test-only control shall be removed."]
pub const AV1_INVERT_TILE_DECODE_ORDER: aom_dec_control_id = 266;
#[doc = " control function to set the skip loop filter flag. Valid values are"]
#[doc = " integers. The decoder will skip the loop filter when its value is set to"]
#[doc = " nonzero. If the loop filter is skipped the decoder may accumulate decode"]
#[doc = " artifacts. The default value is 0."]
pub const AV1_SET_SKIP_LOOP_FILTER: aom_dec_control_id = 267;
#[doc = " control function to retrieve a pointer to the Accounting struct.  When"]
#[doc = " compiled without --enable-accounting, this returns AOM_CODEC_INCAPABLE."]
#[doc = " If called before a frame has been decoded, this returns AOM_CODEC_ERROR."]
#[doc = " The caller should ensure that AOM_CODEC_OK is returned before attempting"]
#[doc = " to dereference the Accounting pointer."]
pub const AV1_GET_ACCOUNTING: aom_dec_control_id = 268;
#[doc = " control function to get last decoded frame quantizer. Returned value uses"]
#[doc = " internal quantizer scale defined by the codec."]
pub const AOMD_GET_LAST_QUANTIZER: aom_dec_control_id = 269;
#[doc = " control function to set the range of tile decoding. A value that is"]
#[doc = " greater and equal to zero indicates only the specific row/column is"]
#[doc = " decoded. A value that is -1 indicates the whole row/column is decoded."]
#[doc = " A special case is both values are -1 that means the whole frame is"]
#[doc = " decoded."]
pub const AV1_SET_DECODE_TILE_ROW: aom_dec_control_id = 270;
#[doc = " control function to set the range of tile decoding. A value that is"]
#[doc = " greater and equal to zero indicates only the specific row/column is"]
#[doc = " decoded. A value that is -1 indicates the whole row/column is decoded."]
#[doc = " A special case is both values are -1 that means the whole frame is"]
#[doc = " decoded."]
pub const AV1_SET_DECODE_TILE_COL: aom_dec_control_id = 271;
#[doc = " control function to set the tile coding mode. A value that is equal to"]
#[doc = "  zero indicates the tiles are coded in normal tile mode. A value that is"]
#[doc = "  1 indicates the tiles are coded in large-scale tile mode."]
pub const AV1_SET_TILE_MODE: aom_dec_control_id = 272;
#[doc = " control function to get the frame header information of an encoded frame"]
#[doc = " in the bitstream. This provides a way to access a frame's header data."]
pub const AV1D_GET_FRAME_HEADER_INFO: aom_dec_control_id = 273;
#[doc = " control function to get the start address and size of a tile in the coded"]
#[doc = " bitstream. This provides a way to access a specific tile's bitstream data."]
pub const AV1D_GET_TILE_DATA: aom_dec_control_id = 274;
#[doc = " control function to set the external references' pointers in the decoder."]
#[doc = "  This is used while decoding the tile list OBU in large-scale tile coding"]
#[doc = "  mode."]
pub const AV1D_SET_EXT_REF_PTR: aom_dec_control_id = 275;
#[doc = " control function to enable the ext-tile software debug and testing code in"]
#[doc = " the decoder."]
pub const AV1D_EXT_TILE_DEBUG: aom_dec_control_id = 276;
#[doc = " control function to enable the row based multi-threading of decoding. A"]
#[doc = " value that is equal to 1 indicates that row based multi-threading is"]
#[doc = " enabled."]
pub const AV1D_SET_ROW_MT: aom_dec_control_id = 277;
#[doc = " control function to indicate whether bitstream is in Annex-B format."]
pub const AV1D_SET_IS_ANNEXB: aom_dec_control_id = 278;
#[doc = " control function to indicate which operating point to use. A scalable"]
#[doc = "  stream may define multiple operating points, each of which defines a"]
#[doc = "  set of temporal and spatial layers to be processed. The operating point"]
#[doc = "  index may take a value between 0 and operating_points_cnt_minus_1 (which"]
#[doc = "  is at most 31)."]
pub const AV1D_SET_OPERATING_POINT: aom_dec_control_id = 279;
#[doc = " control function to indicate whether to output one frame per temporal"]
#[doc = "  unit (the default), or one frame per spatial layer."]
#[doc = "  In a scalable stream, each temporal unit corresponds to a single \"frame\""]
#[doc = "  of video, and within a temporal unit there may be multiple spatial layers"]
#[doc = "  with different versions of that frame."]
#[doc = "  For video playback, only the highest-quality version (within the"]
#[doc = "  selected operating point) is needed, but for some use cases it is useful"]
#[doc = "  to have access to multiple versions of a frame when they are available."]
pub const AV1D_SET_OUTPUT_ALL_LAYERS: aom_dec_control_id = 280;
#[doc = " control function to set an aom_inspect_cb callback that is invoked each"]
#[doc = " time a frame is decoded.  When compiled without --enable-inspection, this"]
#[doc = " returns AOM_CODEC_INCAPABLE."]
pub const AV1_SET_INSPECTION_CALLBACK: aom_dec_control_id = 281;
#[doc = " control function to set the skip film grain flag. Valid values are"]
#[doc = " integers. The decoder will skip the film grain when its value is set to"]
#[doc = " nonzero. The default value is 0."]
pub const AV1D_SET_SKIP_FILM_GRAIN: aom_dec_control_id = 282;
#[doc = " control function to set the skip film grain flag. Valid values are"]
#[doc = " integers. The decoder will skip the film grain when its value is set to"]
#[doc = " nonzero. The default value is 0."]
pub const AOM_DECODER_CTRL_ID_MAX: aom_dec_control_id = 283;
#[doc = "\\enum aom_dec_control_id"]
#[doc = " \\brief AOM decoder control functions"]
#[doc = ""]
#[doc = " This set of macros define the control functions available for the AOM"]
#[doc = " decoder interface."]
#[doc = ""]
#[doc = " \\sa #aom_codec_control"]
pub type aom_dec_control_id = ::std::os::raw::c_uint;
